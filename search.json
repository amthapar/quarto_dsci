[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "chapter2.html",
    "href": "chapter2.html",
    "title": "Tutorial #2",
    "section": "",
    "text": "In this course, we will be using the R software environment for all our analysis. You will learn R and data analysis techniques simultaneously. This tutorial introduces some basic programming concepts and terminology. Instead of asking you to memorize all these concepts and terminology right now, we will guide you so that you will “learn by doing.” To help you learn, we will always use a different font to distinguish regular text from computer_code. In this tutorial, we will review the difference between objects and functions, arithmetic and logical operators, the most common data types in R, and explore a simple dataset. The best way to master these topics is, in our opinions, through deliberate practice with R and lots of repetition.\n\n\n* Be able to explain the difference between a data object and a function.\n* Be familiar with the common types of data and data structures in R.\n* Understand how and when to use arithmetic and logical operators in R.\n* Be able to explore a dataset using basic Base R functions.\n\n\n\nIn R, we first need to grasp the notions of objects and functions. From a task-oriented perspective, using R consists of\n\ncreating or loading data (inputs, material, values), and\ncalling or evaluating functions (commands, actions, verbs) for\ncomputing and constructing new data (outputs, images, tables, results).\n\nConfusingly, both data and functions in R are objects (stuff) and evaluating functions typically returns or creates new objects (more stuff). Thus, the process of computation can be viewed as a cycle that uses data (as input) to create more data (as output). Although any part of a program is an object, functions are those objects that do things by processing or performing tasks on data and create new objects. To distinguish data from functions, think of data as matter (i.e., material, stuff, or values) that are being measured, manipulated, or processed, and of functions as procedures (i.e., actions, operations, or verbs) that measure, manipulate, or process data. Put more succinctly, functions are objects that do things — they process data into other data.\nAlthough this tutorial addresses data and functions in the context of base R, the same distinctions also apply to other packages and languages. In the following, we will introduce some ways to describe data (by type and shape), learn to create new data objects (by assigning them with &lt;-), and apply some pre-defined functions to these data objects. [and to create new data objects?]\n\n\n\n\n\n\nR Notation\n\n\n\nTo make it easier to distinguish between data objects and functions, we will typically add (round) parentheses to function names. Thus, abc() indicates a function, whereas abc indicates a data object. However, keep in mind that there are some R functions that work without parentheses (e.g., arithmetic operators + and * that are positioned between their arguments).\n\n\n\n\n\nFunctions, also called commands, perform tasks in R. They take in inputs called arguments and return outputs. Most functions require the user to manually specify a function’s arguments. For example, if type sqrt() and press Enter/Return, you will get an error message. There are some functions for which the user can either manually specify a function’s arguments or use the function’s default values. For example, the function seq() in R generates a sequence of numbers. If you just run seq() it will return the value 1. That doesn’t seem very useful! This is because the default arguments are set as seq(from = 1, to = 1). Thus, if you don’t pass in different input values for from and to to change this behavior, R just assumes all you want is the number 1. You can change the argument values by updating the values after the = sign. If we try out seq(from = 2, to = 5) or alternatively seq(2:5), we will get the result 2 3 4 5 that we might expect.\nOver the semester you will get lots of practice working with functions and understanding their behaviors. In addition to the sqrt() and the seq() functions, we have also used the install.packages() and the library() functions. There are thousands of functions built into R and even more can be added through packages. These functions do not appear in the workspace because you did not define them, but they are available for immediate use.\n\n\n\nWhen formally dealing with data, it makes sense to distinguish between a variable and its values: A variable is a dimension or property that describes a unit of observation (e.g., a person, a school, a country, etc.) and can typically assume different values. By contrast, values are the concrete instantiations that a variable assigns to every unit of observation and are further characterized by their range (e.g., categorical vs. continuous values) and their type (e.g., numeric, character, or logical values). For instance, an individual can be characterized by the variables name, age, and whether or not they are classified as an adult. The values corresponding to these variables would be of type text (e.g., “Lisa”), numeric (e.g., 16, age in years), and logical (TRUE vs. FALSE, defined as a function of age).\n\n\nTo make the best out of the R programming language, a programmer needs a strong understanding of the basic data types and data structures, and how to operate on them.\nIn R, data is stored in objects that are distinguished by their type and by their shape:\n\nThe most common types of data are:\n\ndoubles - for representing all real numbers (whole numbers and decimals, such as -55, 0.75, 5);\nintegers - for representing only whole numbers (such as -1, 0, 85, 2568);\ncharacters - for representing text or string data (such as “apple”, “laywer”);\nlogicals - for representing a variable with only truth values of type logical TRUE or FALSE (aka. Boolean values);\ntime - for representing dates and times;\n\nOther important data type in R include:\n\nNA - Missing values;\nNaN - Not a Number e.g. sqrt(-4);\nInf - Infinite values e.g. 5/0.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNote that R distinguishes between two numeric data types (integer and double). It defaults to storing numerical data as double. You need to add a L after the number to tell R you want the number stored as an integer or use the function as.integer(). Keep in mind that unless you tell R something is an integer, it will store it as double. This default behavior is helpful since we will mostly be working with doubles, not integers. In general, you can ignore this distinction but occasionally it comes up so it is good to know it exists. Also note that character data type is declared by enclosing it in double quotation marks. Similarly, R will treat numerical data with double quotation marks as character (text/string) data (e.g., “432.5”).\n\n\n\n\n\nhttps://rpubs.com/STEMResearch/data-types-in-r\nThere are two functions, typeof() and class(), that can be applied to any R object to check what type of data object it is. Data types can also be converted from one type to another using the as._____ functions.\nThe function typeof() can be applied to any R object to check what type of data object it is. Data types can also be converted from one type to another using the as._____ functions.\n\n\n\nFunction\nDescription\n\n\n\n\nas.double()\nConvert to double\n\n\nas.integer()\nConvert to integer\n\n\nas.numeric()\nConvert to numeric\n\n\nas.character()\nConvert to character\n\n\nas.logical()\nConvert to logical\n\n\nas.complex()\nConvert to complex\n\n\n\n\n\n\nhttps://bookdown.org/rwnahhas/IntroToR/object-types.html\nThe shape of an object mostly depends on its structure. A clear understanding of R data structures is crucial since these are the objects you will manipulate on a day-to-day basis in R.\nThe most common shapes of data are: + scalars are individual elements (e.g., “A”, 4, TRUE); + vectors are linear chains or sequences of objects (can be either numeric or character but not both); + tables are rectangular data structures with two dimensions (with rows and columns).\nThere are additional data shapes (e.g., multi-dimensional data structures) and types (e.g., for representing categorical or geographical data), but the ones mentioned here are by far the most important ones.\n\n\n\nThe main type of object used in R for representing data is a vector. A vector is a column of numbers or character strings indexed by the integers 1, 2, …, n, where n is the length of the vector. Vectors come in different data types and shapes. They can be either numeric or character but not both. If you attempt to create a vector with both numeric values and character strings, R will convert the numeric values to character.\nWe create a vector of numbers and display it like this:\n\n# this creates a vector of heights, in cm\nheights &lt;- c(203, 148, 156, 158, 167)\n\nThe c() command is shorthand for combine or concatenate, so in the example above we are combining the individual elements (the 5 numbers) into a new vector that is assigned the label heights using &lt;-, the assignment operator. And we can check the values stored in the variable by asking R to print them. You can either type print(heights), or just write the name of the variable alone heights, which will print it by default.\nWe can also create a vector of text elements:\n\n# this creates a vector of text \nnames &lt;- c(\"Ben\", \"Rosa\", \"Sue\", \"Joe\", \"Lucia\")\n\nThe quotes around “Ben”, “Rosa”, etc. are essential here. Without the quotes R will assume there are objects called Ben, Rosa, etc. in the workspace. As these objects don’t exist in R’s memory, there will be an error message.\nNote: If you are using RStudio, they will be stored in our environment located in the top right window.\nWhen simultaneously considering the shape and type of data, we can distinguish and begin to understand data structures.\n\n\n\nData structures are constructs designed to store data. As we mentioned in Section 1.1.3, the data structures of a programming language are similar to the grammatical and spelling rules of natural languages. As long as we reach our goals, we neither care about nor need to know the rules. But whenever unexpected outcomes or errors occur, repairing them in a competent fashion requires considerable background knowledge and experience.\nAlthough the term “data structure” is sometimes used to refer to just the shape of data, understanding the key data structures available in R requires viewing them as a combination of (a) some data shape, and (b) the fact whether they contain a single or multiple types of data.\nTable 1.1 provides an overview of the key data structures provided by the designers of R. Note that Table 1.1 distinguishes between three different data shapes (in its rows) and between data structures for “homogeneous” vs. “heterogeneous” data types (in its columns):\n\n\n\n\nThe most basic computation you can do in R is arithmetic operations. In other words, addition, subtraction, multiplication, division, exponentiation and extraction of roots. In short, R can be used like your pocket calculator, or more likely the one you have on your phone. We demonstrated this in Tutorial #1 when we performed some simple computations. As with many calculators, the operators are + for addition, - for subtraction, * for multiplication, / for division and ^ for exponentiation. Often parentheses are used to clarify the order of operations.\n+ addition\n- subtraction\n* multiplication\n/ division\nabs() absolute value\nx^n raise x to power of some number n\nsqrt() square root of a number or variable ( n^2 does same)\nlog() natural log\nexp() antilog, exponent of variable or number\nlog2() log of other bases, eg. log base 2\n\n2 + 2\n\n\n\nThe main difference between arithmetic operators and logical operators is that logical operators are used to make comparisons and will yield a logical (TRUE/FALSE) output. These are really helpful when we want to identify certain qualities about the data.\nBelow is a list of some common logical operators that can be used on R:\n== is equal to\n!= is not equal to\n&lt; less than\n&gt; greater than\n&lt;= less than or equal to\n&gt;= greater than or equal to\nFor multiple conditions…\n| or operator\n& and operator1\n\nHere’s a helpful visual about logical operators, x is the left circle, y is the right circle.\nExamples of logicals being helpful.\n\n# Examples:\n3 == 4 #FALSE, 3 is not equal to 4\n3 != 4 #TRUE, 3 is not equal to 4\n\n\"cat\" == \"cat\" #TRUE, this works with strings too \"cat\" is the same as \"cat\"\n\n\n\n\n\nLet’s put everything we’ve learned so far into practice and start exploring some real data! Data comes to us in a variety of formats, from pictures to text to numbers. Throughout this book, we’ll focus on datasets that are saved in “spreadsheet”-type format. This is probably the most common way data are collected and saved in many fields. Remember from Subsection 1.2.1 that these “spreadsheet”-type datasets are called data frames in R. We’ll focus on working with data saved as data frames throughout this book.\nLet’s first load all the packages needed for this chapter, assuming you’ve already installed them. Read Section 1.3 for information on how to install and load R packages if you haven’t already."
  },
  {
    "objectID": "chapter2.html#sec-ilo-intro",
    "href": "chapter2.html#sec-ilo-intro",
    "title": "Tutorial #2",
    "section": "",
    "text": "* Be able to explain the difference between a data object and a function.\n* Be familiar with the common types of data and data structures in R.\n* Understand how and when to use arithmetic and logical operators in R.\n* Be able to explore a dataset using basic Base R functions."
  },
  {
    "objectID": "chapter2.html#sec-intro-basic_terms",
    "href": "chapter2.html#sec-intro-basic_terms",
    "title": "Tutorial #2",
    "section": "",
    "text": "In R, we first need to grasp the notions of objects and functions. From a task-oriented perspective, using R consists of\n\ncreating or loading data (inputs, material, values), and\ncalling or evaluating functions (commands, actions, verbs) for\ncomputing and constructing new data (outputs, images, tables, results).\n\nConfusingly, both data and functions in R are objects (stuff) and evaluating functions typically returns or creates new objects (more stuff). Thus, the process of computation can be viewed as a cycle that uses data (as input) to create more data (as output). Although any part of a program is an object, functions are those objects that do things by processing or performing tasks on data and create new objects. To distinguish data from functions, think of data as matter (i.e., material, stuff, or values) that are being measured, manipulated, or processed, and of functions as procedures (i.e., actions, operations, or verbs) that measure, manipulate, or process data. Put more succinctly, functions are objects that do things — they process data into other data.\nAlthough this tutorial addresses data and functions in the context of base R, the same distinctions also apply to other packages and languages. In the following, we will introduce some ways to describe data (by type and shape), learn to create new data objects (by assigning them with &lt;-), and apply some pre-defined functions to these data objects. [and to create new data objects?]\n\n\n\n\n\n\nR Notation\n\n\n\nTo make it easier to distinguish between data objects and functions, we will typically add (round) parentheses to function names. Thus, abc() indicates a function, whereas abc indicates a data object. However, keep in mind that there are some R functions that work without parentheses (e.g., arithmetic operators + and * that are positioned between their arguments)."
  },
  {
    "objectID": "chapter2.html#sec-intro-functions",
    "href": "chapter2.html#sec-intro-functions",
    "title": "Tutorial #2",
    "section": "",
    "text": "Functions, also called commands, perform tasks in R. They take in inputs called arguments and return outputs. Most functions require the user to manually specify a function’s arguments. For example, if type sqrt() and press Enter/Return, you will get an error message. There are some functions for which the user can either manually specify a function’s arguments or use the function’s default values. For example, the function seq() in R generates a sequence of numbers. If you just run seq() it will return the value 1. That doesn’t seem very useful! This is because the default arguments are set as seq(from = 1, to = 1). Thus, if you don’t pass in different input values for from and to to change this behavior, R just assumes all you want is the number 1. You can change the argument values by updating the values after the = sign. If we try out seq(from = 2, to = 5) or alternatively seq(2:5), we will get the result 2 3 4 5 that we might expect.\nOver the semester you will get lots of practice working with functions and understanding their behaviors. In addition to the sqrt() and the seq() functions, we have also used the install.packages() and the library() functions. There are thousands of functions built into R and even more can be added through packages. These functions do not appear in the workspace because you did not define them, but they are available for immediate use."
  },
  {
    "objectID": "chapter2.html#sec-intro-data",
    "href": "chapter2.html#sec-intro-data",
    "title": "Tutorial #2",
    "section": "",
    "text": "When formally dealing with data, it makes sense to distinguish between a variable and its values: A variable is a dimension or property that describes a unit of observation (e.g., a person, a school, a country, etc.) and can typically assume different values. By contrast, values are the concrete instantiations that a variable assigns to every unit of observation and are further characterized by their range (e.g., categorical vs. continuous values) and their type (e.g., numeric, character, or logical values). For instance, an individual can be characterized by the variables name, age, and whether or not they are classified as an adult. The values corresponding to these variables would be of type text (e.g., “Lisa”), numeric (e.g., 16, age in years), and logical (TRUE vs. FALSE, defined as a function of age).\n\n\nTo make the best out of the R programming language, a programmer needs a strong understanding of the basic data types and data structures, and how to operate on them.\nIn R, data is stored in objects that are distinguished by their type and by their shape:\n\nThe most common types of data are:\n\ndoubles - for representing all real numbers (whole numbers and decimals, such as -55, 0.75, 5);\nintegers - for representing only whole numbers (such as -1, 0, 85, 2568);\ncharacters - for representing text or string data (such as “apple”, “laywer”);\nlogicals - for representing a variable with only truth values of type logical TRUE or FALSE (aka. Boolean values);\ntime - for representing dates and times;\n\nOther important data type in R include:\n\nNA - Missing values;\nNaN - Not a Number e.g. sqrt(-4);\nInf - Infinite values e.g. 5/0.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNote that R distinguishes between two numeric data types (integer and double). It defaults to storing numerical data as double. You need to add a L after the number to tell R you want the number stored as an integer or use the function as.integer(). Keep in mind that unless you tell R something is an integer, it will store it as double. This default behavior is helpful since we will mostly be working with doubles, not integers. In general, you can ignore this distinction but occasionally it comes up so it is good to know it exists. Also note that character data type is declared by enclosing it in double quotation marks. Similarly, R will treat numerical data with double quotation marks as character (text/string) data (e.g., “432.5”).\n\n\n\n\n\nhttps://rpubs.com/STEMResearch/data-types-in-r\nThere are two functions, typeof() and class(), that can be applied to any R object to check what type of data object it is. Data types can also be converted from one type to another using the as._____ functions.\nThe function typeof() can be applied to any R object to check what type of data object it is. Data types can also be converted from one type to another using the as._____ functions.\n\n\n\nFunction\nDescription\n\n\n\n\nas.double()\nConvert to double\n\n\nas.integer()\nConvert to integer\n\n\nas.numeric()\nConvert to numeric\n\n\nas.character()\nConvert to character\n\n\nas.logical()\nConvert to logical\n\n\nas.complex()\nConvert to complex\n\n\n\n\n\n\nhttps://bookdown.org/rwnahhas/IntroToR/object-types.html\nThe shape of an object mostly depends on its structure. A clear understanding of R data structures is crucial since these are the objects you will manipulate on a day-to-day basis in R.\nThe most common shapes of data are: + scalars are individual elements (e.g., “A”, 4, TRUE); + vectors are linear chains or sequences of objects (can be either numeric or character but not both); + tables are rectangular data structures with two dimensions (with rows and columns).\nThere are additional data shapes (e.g., multi-dimensional data structures) and types (e.g., for representing categorical or geographical data), but the ones mentioned here are by far the most important ones.\n\n\n\nThe main type of object used in R for representing data is a vector. A vector is a column of numbers or character strings indexed by the integers 1, 2, …, n, where n is the length of the vector. Vectors come in different data types and shapes. They can be either numeric or character but not both. If you attempt to create a vector with both numeric values and character strings, R will convert the numeric values to character.\nWe create a vector of numbers and display it like this:\n\n# this creates a vector of heights, in cm\nheights &lt;- c(203, 148, 156, 158, 167)\n\nThe c() command is shorthand for combine or concatenate, so in the example above we are combining the individual elements (the 5 numbers) into a new vector that is assigned the label heights using &lt;-, the assignment operator. And we can check the values stored in the variable by asking R to print them. You can either type print(heights), or just write the name of the variable alone heights, which will print it by default.\nWe can also create a vector of text elements:\n\n# this creates a vector of text \nnames &lt;- c(\"Ben\", \"Rosa\", \"Sue\", \"Joe\", \"Lucia\")\n\nThe quotes around “Ben”, “Rosa”, etc. are essential here. Without the quotes R will assume there are objects called Ben, Rosa, etc. in the workspace. As these objects don’t exist in R’s memory, there will be an error message.\nNote: If you are using RStudio, they will be stored in our environment located in the top right window.\nWhen simultaneously considering the shape and type of data, we can distinguish and begin to understand data structures.\n\n\n\nData structures are constructs designed to store data. As we mentioned in Section 1.1.3, the data structures of a programming language are similar to the grammatical and spelling rules of natural languages. As long as we reach our goals, we neither care about nor need to know the rules. But whenever unexpected outcomes or errors occur, repairing them in a competent fashion requires considerable background knowledge and experience.\nAlthough the term “data structure” is sometimes used to refer to just the shape of data, understanding the key data structures available in R requires viewing them as a combination of (a) some data shape, and (b) the fact whether they contain a single or multiple types of data.\nTable 1.1 provides an overview of the key data structures provided by the designers of R. Note that Table 1.1 distinguishes between three different data shapes (in its rows) and between data structures for “homogeneous” vs. “heterogeneous” data types (in its columns):"
  },
  {
    "objectID": "chapter2.html#sec-intro-operations",
    "href": "chapter2.html#sec-intro-operations",
    "title": "Tutorial #2",
    "section": "",
    "text": "The most basic computation you can do in R is arithmetic operations. In other words, addition, subtraction, multiplication, division, exponentiation and extraction of roots. In short, R can be used like your pocket calculator, or more likely the one you have on your phone. We demonstrated this in Tutorial #1 when we performed some simple computations. As with many calculators, the operators are + for addition, - for subtraction, * for multiplication, / for division and ^ for exponentiation. Often parentheses are used to clarify the order of operations.\n+ addition\n- subtraction\n* multiplication\n/ division\nabs() absolute value\nx^n raise x to power of some number n\nsqrt() square root of a number or variable ( n^2 does same)\nlog() natural log\nexp() antilog, exponent of variable or number\nlog2() log of other bases, eg. log base 2\n\n2 + 2\n\n\n\nThe main difference between arithmetic operators and logical operators is that logical operators are used to make comparisons and will yield a logical (TRUE/FALSE) output. These are really helpful when we want to identify certain qualities about the data.\nBelow is a list of some common logical operators that can be used on R:\n== is equal to\n!= is not equal to\n&lt; less than\n&gt; greater than\n&lt;= less than or equal to\n&gt;= greater than or equal to\nFor multiple conditions…\n| or operator\n& and operator1\n\nHere’s a helpful visual about logical operators, x is the left circle, y is the right circle.\nExamples of logicals being helpful.\n\n# Examples:\n3 == 4 #FALSE, 3 is not equal to 4\n3 != 4 #TRUE, 3 is not equal to 4\n\n\"cat\" == \"cat\" #TRUE, this works with strings too \"cat\" is the same as \"cat\""
  },
  {
    "objectID": "chapter2.html#sec-intro-explore_dataset",
    "href": "chapter2.html#sec-intro-explore_dataset",
    "title": "Tutorial #2",
    "section": "",
    "text": "Let’s put everything we’ve learned so far into practice and start exploring some real data! Data comes to us in a variety of formats, from pictures to text to numbers. Throughout this book, we’ll focus on datasets that are saved in “spreadsheet”-type format. This is probably the most common way data are collected and saved in many fields. Remember from Subsection 1.2.1 that these “spreadsheet”-type datasets are called data frames in R. We’ll focus on working with data saved as data frames throughout this book.\nLet’s first load all the packages needed for this chapter, assuming you’ve already installed them. Read Section 1.3 for information on how to install and load R packages if you haven’t already."
  },
  {
    "objectID": "chapter2.html#footnotes",
    "href": "chapter2.html#footnotes",
    "title": "Tutorial #2",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://methodenlehre.github.io/SGSCLM-R-course/the-r-language.html↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AT",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "new.html",
    "href": "new.html",
    "title": "Tutorial #1",
    "section": "",
    "text": "This tutorial focuses on getting you started in R and RStudio. R is a programming language that you will write code in and RStudio is a program that makes working in R easier. There are two strategies for working with R and RStudio. The user can either install R and RStudio on their computer and work with them locally OR the user can work with them remotely via an internet browser. In this course, we will work with R and RStudio remotely via PositCloud.\n\n\n\n\n\n\nInterested students can refer to Appendix A for technical details on installing R and RStudio locally on their computer. If you already have R and/or RStudio installed, we recommend updating to the latest version of R and RStudio. Appendix B has more details on how to do that.\n\n\n\n\n\n* Understand the difference between R and RStudio\n* Become familiar with the main components in RStudio\n* Be able to write and run code in the console and in a R Script\n* Be able to install add-on packages\n* Be able to get help for packages and functions\n* Be able to customize RStudio\n\n\n\nAs previously mentioned, R is a programming language that we will use to write code for working with data. RStudio is an Integrated Development Environment (IDE) for R. RStudio is dependent on R but separate from it. It provides a useful interface for working with R and has several advantages over the default R interface. Think of it as knowing English and using a plain text editor like NotePad to write a book versus using a word processor like Microsoft Word. You could do it, but it would be much harder without things like spell-checking and formatting and you wouldn’t be able to use some of the advanced features that Word has developed. In a similar way, you can use R without RStudio but we wouldn’t recommend it. RStudio serves as a text editor, file manager, spreadsheet viewer, and much more. The key thing to remember is that although you will do all of your work using RStudio for this course, you are actually working with two pieces of software, which means that from time to time, both of them may have separate updates.\nRStudio runs on Mac, PC, and Linux machines and provides a simplified interface that looks and feels identical on all of them. While it can be installed on your own computer, for this course you will be asked to login to a shared RStudio Cloud server (PositCloud) from a web browser. There are several advantages to using the web browser application of RStudio Cloud. It allows you to write and access R code wherever you go. It even works on your tablet because it does not require installation. It also makes it much easier to collaborate with others, and since no installation is required, you can work on projects on any device as long as you are connected to the internet. Another significant advantage of using RStudio in the cloud is that you can run time-consuming scripts without bogging down your own device. However, because RStudio Cloud requires an internet connection, it will run slower if your internet connection is not fast or stable.\n\n\nThe interface for working with RStudio both in the cloud or locally is largely the same and consists of 4 window “panes”. Several of the panes are further subdivided into multiple tabs.\n\n\n\n\n\nRStudio Layout with R script in upper left quadrant.\n\n\n\n\nLet’s look in more detail at each of these four windows. By default, the upper left pane is the source pane, where you view, write, and edit code from files and view data tables in a spreadsheet format. When you first open RStudio, this pane won’t display until we open a document or load in some data – don’t worry, we’ll get to that soon.\nThe lower left pane is the console pane, where you can view the output of your coding and computations. It is also possible to write code directly into the console. However, keep in mind that the code you write in the console will run and can create objects that will be saved in the environment, but the code itself won’t be saved. You need to write your code into a script in the source pane to save it, which we’ll cover in more detail in Section 0.3 below.\nThe right panes have several different tabs that show you information about your code. The most used tabs in the upper right pane is the Environment tab. The Environment tab lists some information about the objects that you have defined in your code.\nIn the lower right pane are tabs for browsing files, viewing plots, managing R packages, reading help files, and for viewing html documents and presentations. The most used tabs are the Files tab for directory structure, the Plots tab for plots made in a script, the Packages tab for managing add-on packages (see Section 0.4), and the Help tab which displays help pages for R functions and packages. We’ll learn more about the Help tab in Section 0.4.5.\n\n\n\nAt the top of the RStudio Desktop there are the following set of menus.\n\nFile\n\nThe File menu is primarily for the opening, closing and saving of files. Often, these files will be R scripts that open in the script editor. But they could also be R data file, RMarkdown documents, Shiny apps, etc. Here, we can also open and close RStudio projects, which is a very useful organizing feature to which we will return below.\n\nEdit\n\nThe Edit menu primarily provides tools for standard file editing operations such as copy, cut, paste, and search and replace, undo and redo, etc. It also provides code folding features, which is very useful for reducing clutter when editing relatively large R scripts.\n\nCode\n\nThe Code menu provides many useful tools for making editing and running code considerably easier and more efficient. We will explore these features in more depth in subsequent sections, but they include the adding and removing code comments, reformatting code, jumping to functions within and between scripts, creating code regions that can then be run independently, and so on.\n\nView\n\nThe View menu primarily provides options to move around RStudio quickly. These options are all bound to key combinations, as are many other RStudio features, and learning these key combinations is certainly worthwhile because of the eventual speed and efficiency gains that they provide.\n\nPlots\n\nThe Plots menu primarily provides features that are also available in the Plots window itself.\n\nSession\n\nThe Session menu allows us to start new separate RStudio sessions. These then run independently of one another. Also in the Session menu, we can restart the R session in the background, which is a useful session. Remember that RStudio itself is just a front to an R session that runs in the background. Sometimes it is a good idea to restart the R session so as to start in a clean and fresh state. This can be done through the Session menu Restart R option, which is also bound to the keys Ctrl+Shift+F10. Also in Session are options to set R’s working directory. This concept of a working directory is a simple but important one, and we will cover it below.\n\nBuild\n\nThe Build menu provides features for running scripts for software builds. This is particularly used for creating R packages.\n\nDebug\n\nThe Debug menu provides tools for debugging our R code. Debugging usually only becomes a necessity when R programming per se, and not something that is usually required when writing individual commands or scripts of commands.\n\nProfile\n\nThe Profile menu provides tools for profiling the running and efficiency of our R code. Code efficiency is certainly not something that those new to R need to worry about, but when writing relatively complex code, profiling can identify bottlenecks.\n\nTools\n\nThe Tools menu provides miscellaneous tools such as for working with version control using Git, accessing the computer’s operating system’s command line interface, installing and updating packages (as could also be done in the Package window), viewing and modifying keyboard shortcuts. Here, we can also access the Global Options and Project Options. Global Options is where all the general R and RStudio settings are set. One immediately useful setting here is the Appearance setting, which can allow us to change the font, font size, and colour theme of RStudio to suit our preference. Project Options are for the RStudio project specific settings. We will return to these below.\n\nHelp\n\nThe Help menu provides much the same information as can be found in the Help window. It also provides some additional links to online resources, such as RStudio’s cheatsheets1, which are excellent concise guides to many different R and RStudio topics. Also available in the Help menu are tools to access RStudio internal diagnostics. This is only that is needed if and when RStudio seems to be malfunctioning.\n\n\n\n\n\n\nR is a command based system. We type commands, R translates them into machine instructions, which our computer then executes, and then we often, but not necessarily, get back some output. The commands can be typed into the R console, or else they can be put into a script and run as a batch.\n\n\nWhen learning R, it is usually best to start with typing commands in the R console. When we open RStudio initially, our console will usually look something like this:\nR version 4.3.1 (2023-06-16 ucrt) -- \"Beagle Scouts\"\nCopyright (C) 2023 The R Foundation for Statistical Computing\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nType 'demo()' for some demos, 'help()' for on-line help, or\n'help.start()' for an HTML browser interface to help.\nType 'q()' to quit R.\n\n&gt; \nNotice that at the bottom, there is a single line beginning with &gt;. This is the R console’s command prompt, and it is where we type our commands. We then press Enter, and our command is executed. The output of the command, if any, is displayed on the next line or lines, and then a new &gt; prompt appears.\nWhile R is much more than a simple calculator, a useful way to familiarize yourself with R and the console is to do some simple calculator-like computations. Most of this will work just like you would expect from a typical calculator.\nFirst, click into the console with your mouse, type 10 + 5 into your console and press Enter/Return ↵ on your keyboard. The result should be pretty obvious. Now, type 6 * 15 into your console and press Enter/Return ↵ on your keyboard. Next, type sqrt(25) into your console and press Enter/Return ↵ on your keyboard. This last example demonstrates how functions are called within R. The code sqrt() calls the square root function in R and asks R to compute the square root of the number provided within the parentheses. Now, type calc1 &lt;- sqrt(25) into your console and hit Enter/Return. This time R does not return a value but instead has stored the value in memory by assigning it to a variable. We do this with the assignment operator &lt;-, which is a &lt; symbol followed directly by a - symbol. The &lt;- can be typed by key combination Alt+- (i.e Alt key and minus key together) or Option+- on the Mac. This object is now listed in your Environment pane. Type calc1 into your console and press Enter/Return ↵ on your keyboard, to print the value saved in the object. Quick Note: In the previous commands, we put a space between around the +, *, &lt;- operators. This is a matter of recommended style to improve readability, not a requirement.\n\n\n\n\n\n\nBroom to the Rescue\n\n\n\nIn the top right of the console pane, you will find a symbol that looks like a broom. This is quite an important icon because it clears your console. Sometimes the console can become very cluttered and difficult to read. When you want to declutter your console, click the broom icon and clear the console of all text. I use it so frequently that I strongly recommend learning the keyboard shortcut, which is Ctrl + L on PC and Mac.\n\n\n\n\n\nRather than typing R commands into the Console, we typically write short programs, known as “R scripts” that contain the R commands that we wish to execute. This allows for reproducibility because everytime you run your R script you’ll get the same result (assuming the input is the same) or you could give your script to someone else and they’ll get the same result as well.\nTo create a new R Script, select File, then New File, then R Script from the RStudio menu. A file editor tab will open in the Source panel. R code can be entered here, and buttons and menu items are provided to run all the code (called sourcing the file) or to run the code on a single line or in a selected section of the file.\n\n\n\n\n\nCreating a new R Script.\n\n\n\n\nNext, type the following three lines of commands into your R script or copy and paste the code into your R script and update the code with your responses:\n\n\n\nType the code in the R Script file. Ignore the numbers listed to the left of the code.\n\nmyname &lt;- \"Your Name\"   \nmyfavfood &lt;- \"Name of your Favorite Food\"  \npaste(\"My name is\", myname, \"and I really like to eat\", myfavfood)\n\n\nYou may now run each line of your script by clicking on the RUN button, or by pressing the Ctrl + Enter (Cmd + Enter for Macs) keys simultaneously. Notice that R will continue to provide the output in the console, but pressing Enter by itself doesn’t make R run any command.\nLet’s save your first R script. Select File, then Save to give your script a name and save it in your working directory. Congratulations! You have created and saved your first R Script file.\n\n\n\n\nWhen you install R you will have access to a range of functions including options for data wrangling and statistical analysis. The functions that are included in the default installation are typically referred to as “base R” and you can think of them like the default apps that come pre-loaded on your phone.\nOne of the great things about R, however, is that it is user extensible: anyone can create a new add-on that extends its functionality. There are currently thousands of packages that R users have created to solve many different kinds of problems, or just simply to have fun. For example, there are packages for data visualization, machine learning, interactive dashboards, web scraping, and playing games such as Sudoku.\nAdd-on packages are not distributed with base R, but have to be downloaded and installed from an archive, in the same way that you would, for instance, download and install PokemonGo on your smartphone. The main repository where packages reside is called CRAN`, the Comprehensive R Archive Network.\nThere is an important distinction between installing a package and loading a package.\n\n\nThis is done using the function install.packages(). This is like installing an app on your phone: you only have to do it once and the app will remain installed until you remove it. For instance, if you want to use PokemonGo on your phone, you install it once from the App Store or Play Store; you don’t have to re-install it each time you want to use it. Once you launch the app, it will run in the background until you close it or restart your phone. Likewise, when you install a package, the package will be available (but not loaded) every time you open up R.\nInstall the dslabs package on your system. This package contains 26 different datasets and we will explore some of these datasets over the next few weeks.\n\n\n\nRun in the console\n\n#Type the code below in the console. Ignore the number listed to the left of the code.\ninstall.packages(\"dslabs\")\n\n\n\n\n\n\n\n\nInstall packages from the console only\n\n\n\nNever install a package from inside a script. Only do this from the console pane or the packages tab of the lower right pane.\n\n\nHere are some other packages you’ll want to install for the first two chapters.\n\n\n\nRun in the console\n\n#Type the code below in the console. Ignore the number listed to the left of the code.\ninstall.packages(\"beepr\") # for beeps\ninstall.packages(\"rmarkdown\") # for creating R markdown files\ninstall.packages(\"devtools\")  # for installing packages from github\n\n\nThe hash (#) marks everything to the right of it as comment. Using comments can be very useful for annotating your code, and it improves the readability too. It will also help you to remember why/what you done months later, when you return to your code that you have inevitably forgotten!\nOnce you’ve installed the devtools package, you can also install packages from repositories other than CRAN, such as github. The following code installs the development version of a package for making waffle plots.\n\n\n\nRun in the console\n\n# install waffle package. Ignore the number listed to the left of the code.\ndevtools::install_github(\"hrbrmstr/waffle\")\n\n\n\n\n\nThis is done using the library() function. This is like launching an app on your phone: the functionality is only there when the app is launched and remains there until you close the app or restart RStudio. For example, when you run library(devtools) within a session, the functions in the package referred to by devtools will be made available for your R session. The next time you start RStudio, you will need to run library(devtools) again if you want to access that package.\nAfter installing the beepr package, you can load it for your current R session as follows:\n\n\n\nRun in the console\n\nlibrary(beepr)\n\n\nYou might get some red text when you load a package, this is normal. It is usually warning you that this package has functions that have the same name as other packages you’ve already loaded.\n\n\n\n\n\n\nNote\n\n\n\nYou can use the convention package::function() to indicate in which add-on package a function resides. For instance, if you see readr::read_csv(), that refers to the function read_csv() in the {readr} add-on package. If the package is loaded using library(), you don’t have to specify the package name before a function unless there is a conflict (e.g., you have two packages loaded that have a function with the same name).\n\n\n\n\n\nNow you can run the function beep().\n\n\n\nRun in the console\n\nbeep()\n\n\nA function is a name that refers to some code you can reuse. We’ll start by using functions that are provided for you in packages, but you can also write your own functions. After the function name, there is a pair of parentheses, which contain zero or more arguments. These are options that you can set. In the example above, the sound argument has a default value of 1, which makes a “ping” sound. Try changing the argument to an integer between 1 and 11.\n\n\n\nRun in the console\n\nbeep(sound = 8)\n\n\n\n\n\nWe have pre-installed the course workspace with the package tidyverse. This is the main package we will use throughout this course for data wrangling, summaries, and visualization.\ntidyverse is a meta-package that loads several packages we’ll be using in almost every chapter in this book:\n\nggplot2, for data visualisation (?@sec-viz)\nreadr, for data import (?@sec-data)\ntibble, for tables (?@sec-data)\ntidyr, for data tidying (?@sec-tidy)\ndplyr, for data manipulation (?@sec-wrangle)\nstringr, for string data\nforcats, for categorical data\npurrr, for repeating things\n\nWhen you install tidyverse, it also installs some other useful packages that you can load individually. You can get the full list using tidyverse_packages(), but the packages we’ll be using in this book are:\n\ngooglesheets4, for working with Google spreadsheets\nreadxl, for Excel files\nlubridate, for working with dates\nhms, for working with times\nrvest, for web scraping\n\n\n\n\nWhen you load the tidyverse it automatically loads all of the above packages, however, it can be helpful to know which package a function comes from if you need to Google it.\nIf the package isn’t loaded, use ?package_name::function_name or specify the package in the help() function. When you aren’t sure what package the function is in, use the shortcut ??function_name.\n\n\n\nRun in the console\n\n# if the package is loaded\n?beepr\nhelp(\"beepr\")\n\n# works whether or not the package is loaded\n?beepr::beep\nhelp(\"beep\", package=\"beepr\") \n\n# shows a list of potentially matching functions\n??beep\n\n\n\n\n\n\nYou can customize how RStudio looks to make it work for you. For example, you can adjust the size of the panes by moving the gray lines which separate the four panes. The panes can be minimized or maximized using the icons on the right side of the gray bar at the the top of each pane. You also can change the location of panes and what tabs are shown under Tools &gt; Global Options… &gt; Pane Layout.\nMore importantly, you can change the default font, font size, and general appearance of R Studio, including it’s color scheme. Click Tools &gt; Global Options &gt; Appearance. Play around with the settings and see what you prefer - you’re going to spend a lot of time with RStudio, it might as well look nice!\n\n\n\n\n\n\n\nOver the semester, you will be learning how to make reproducible reports using rmarkdown. This involves writing scripts that transform data, create summaries and visualizations, and embed them in a report in a way that always provides the same results. We will go into more details about RMarkdown in the next tutorial.\nWhen you do things reproducibly, others (and most importantly future you) can understand and check your work. You can also reuse your work more easily. For example, if you need to create a report every month with the social media analytics for your company, a reproducible report allows you to download a new month’s data and create the report within seconds. It might take a little longer to set up the report in the first instance with reproducible methods, but the time it saves you in the long run is invaluable.\nhttps://bookdown.org/daniel_dauber_io/r4np_book/setting-up-r-and-rstudio.html#when-you-first-start-rstudio\nWe recommend that you make the following changes to your RStudio settings to set yourself up for success right from the beginning. To open the Rstudio settings you have to click on\nRStudio &gt; Tools &gt; Global Options or press ⌘ + , if you are on a Mac.\nRStudio &gt; Tools &gt; Global Options or press Ctrl + , if you work on a Windows computer.\n\n\n\n\n\nOn the first tab, i.e. General &gt; Basic, we should make one of the most significant changes. Deactivate every option that starts with Restore. This will ensure that every time you start RStudio, you begin with a clean slate. At first sight, it might sound counter-intuitive not to restart everything where you left off, but it is essential to make all your projects easily reproducible. Furthermore, if you work together with others, not restoring your personal settings also ensures that your programming works across different computers. Therefore, I recommend having the following unticked:\nRestore most recently opened project at startup,\nRestore previously open source documents at startup,\nRestore .Rdata into workspace at startup\nIn the same tab under Workspace, select Never for the setting Save workspace to .RData on exit. One might think it is wise to keep intermediary results stored from one R session to another. However, I often found myself fixing issues due to this lazy method, and my code became less reliable and, therefore, reproducible. With experience, you will find that this avoids many headaches.\nIn the Code &gt; Editing tab, make sure to have at least the first five options ticked, especially the Auto-indent code after paste. This setting will save time when trying to format your coding appropriately, making it easier to read. Indentation is the primary way of making your code look more readable and less like a series of characters that appear almost random.\n\n\n\n\n\n\n\n\nIf you have the above settings configured correctly, when you open up RStudio and start writing code, loading packages, and creating objects, you will be doing so in a new session and your Environment tab should be completely empty. If you find that your code isn’t working and you can’t figure out why, it might be worth restarting your R session. This will clear the environment and detach all loaded packages - think of it like restarting your phone. There are several ways that you can restart R:\n\nMenu: Session &gt; Restart R\nCmd-Shift-F10 or Ctl-Shift-F10\ntype .rs.restartR() in the console\n\nTry doing each of these now. Additionally, doing so prior to running any new R script is good practice because it ensures that our script will not have any hidden dependencies, and that any data structures or functions that the code does depend on are created from the code contained in the script."
  },
  {
    "objectID": "new.html#sec-ilo-intro",
    "href": "new.html#sec-ilo-intro",
    "title": "Tutorial #1",
    "section": "",
    "text": "* Understand the difference between R and RStudio\n* Become familiar with the main components in RStudio\n* Be able to write and run code in the console and in a R Script\n* Be able to install add-on packages\n* Be able to get help for packages and functions\n* Be able to customize RStudio"
  },
  {
    "objectID": "new.html#sec-intro-rstudio_ide",
    "href": "new.html#sec-intro-rstudio_ide",
    "title": "Tutorial #1",
    "section": "",
    "text": "As previously mentioned, R is a programming language that we will use to write code for working with data. RStudio is an Integrated Development Environment (IDE) for R. RStudio is dependent on R but separate from it. It provides a useful interface for working with R and has several advantages over the default R interface. Think of it as knowing English and using a plain text editor like NotePad to write a book versus using a word processor like Microsoft Word. You could do it, but it would be much harder without things like spell-checking and formatting and you wouldn’t be able to use some of the advanced features that Word has developed. In a similar way, you can use R without RStudio but we wouldn’t recommend it. RStudio serves as a text editor, file manager, spreadsheet viewer, and much more. The key thing to remember is that although you will do all of your work using RStudio for this course, you are actually working with two pieces of software, which means that from time to time, both of them may have separate updates.\nRStudio runs on Mac, PC, and Linux machines and provides a simplified interface that looks and feels identical on all of them. While it can be installed on your own computer, for this course you will be asked to login to a shared RStudio Cloud server (PositCloud) from a web browser. There are several advantages to using the web browser application of RStudio Cloud. It allows you to write and access R code wherever you go. It even works on your tablet because it does not require installation. It also makes it much easier to collaborate with others, and since no installation is required, you can work on projects on any device as long as you are connected to the internet. Another significant advantage of using RStudio in the cloud is that you can run time-consuming scripts without bogging down your own device. However, because RStudio Cloud requires an internet connection, it will run slower if your internet connection is not fast or stable.\n\n\nThe interface for working with RStudio both in the cloud or locally is largely the same and consists of 4 window “panes”. Several of the panes are further subdivided into multiple tabs.\n\n\n\n\n\nRStudio Layout with R script in upper left quadrant.\n\n\n\n\nLet’s look in more detail at each of these four windows. By default, the upper left pane is the source pane, where you view, write, and edit code from files and view data tables in a spreadsheet format. When you first open RStudio, this pane won’t display until we open a document or load in some data – don’t worry, we’ll get to that soon.\nThe lower left pane is the console pane, where you can view the output of your coding and computations. It is also possible to write code directly into the console. However, keep in mind that the code you write in the console will run and can create objects that will be saved in the environment, but the code itself won’t be saved. You need to write your code into a script in the source pane to save it, which we’ll cover in more detail in Section 0.3 below.\nThe right panes have several different tabs that show you information about your code. The most used tabs in the upper right pane is the Environment tab. The Environment tab lists some information about the objects that you have defined in your code.\nIn the lower right pane are tabs for browsing files, viewing plots, managing R packages, reading help files, and for viewing html documents and presentations. The most used tabs are the Files tab for directory structure, the Plots tab for plots made in a script, the Packages tab for managing add-on packages (see Section 0.4), and the Help tab which displays help pages for R functions and packages. We’ll learn more about the Help tab in Section 0.4.5.\n\n\n\nAt the top of the RStudio Desktop there are the following set of menus.\n\nFile\n\nThe File menu is primarily for the opening, closing and saving of files. Often, these files will be R scripts that open in the script editor. But they could also be R data file, RMarkdown documents, Shiny apps, etc. Here, we can also open and close RStudio projects, which is a very useful organizing feature to which we will return below.\n\nEdit\n\nThe Edit menu primarily provides tools for standard file editing operations such as copy, cut, paste, and search and replace, undo and redo, etc. It also provides code folding features, which is very useful for reducing clutter when editing relatively large R scripts.\n\nCode\n\nThe Code menu provides many useful tools for making editing and running code considerably easier and more efficient. We will explore these features in more depth in subsequent sections, but they include the adding and removing code comments, reformatting code, jumping to functions within and between scripts, creating code regions that can then be run independently, and so on.\n\nView\n\nThe View menu primarily provides options to move around RStudio quickly. These options are all bound to key combinations, as are many other RStudio features, and learning these key combinations is certainly worthwhile because of the eventual speed and efficiency gains that they provide.\n\nPlots\n\nThe Plots menu primarily provides features that are also available in the Plots window itself.\n\nSession\n\nThe Session menu allows us to start new separate RStudio sessions. These then run independently of one another. Also in the Session menu, we can restart the R session in the background, which is a useful session. Remember that RStudio itself is just a front to an R session that runs in the background. Sometimes it is a good idea to restart the R session so as to start in a clean and fresh state. This can be done through the Session menu Restart R option, which is also bound to the keys Ctrl+Shift+F10. Also in Session are options to set R’s working directory. This concept of a working directory is a simple but important one, and we will cover it below.\n\nBuild\n\nThe Build menu provides features for running scripts for software builds. This is particularly used for creating R packages.\n\nDebug\n\nThe Debug menu provides tools for debugging our R code. Debugging usually only becomes a necessity when R programming per se, and not something that is usually required when writing individual commands or scripts of commands.\n\nProfile\n\nThe Profile menu provides tools for profiling the running and efficiency of our R code. Code efficiency is certainly not something that those new to R need to worry about, but when writing relatively complex code, profiling can identify bottlenecks.\n\nTools\n\nThe Tools menu provides miscellaneous tools such as for working with version control using Git, accessing the computer’s operating system’s command line interface, installing and updating packages (as could also be done in the Package window), viewing and modifying keyboard shortcuts. Here, we can also access the Global Options and Project Options. Global Options is where all the general R and RStudio settings are set. One immediately useful setting here is the Appearance setting, which can allow us to change the font, font size, and colour theme of RStudio to suit our preference. Project Options are for the RStudio project specific settings. We will return to these below.\n\nHelp\n\nThe Help menu provides much the same information as can be found in the Help window. It also provides some additional links to online resources, such as RStudio’s cheatsheets1, which are excellent concise guides to many different R and RStudio topics. Also available in the Help menu are tools to access RStudio internal diagnostics. This is only that is needed if and when RStudio seems to be malfunctioning."
  },
  {
    "objectID": "new.html#sec-intro-scripts",
    "href": "new.html#sec-intro-scripts",
    "title": "Tutorial #1",
    "section": "",
    "text": "R is a command based system. We type commands, R translates them into machine instructions, which our computer then executes, and then we often, but not necessarily, get back some output. The commands can be typed into the R console, or else they can be put into a script and run as a batch.\n\n\nWhen learning R, it is usually best to start with typing commands in the R console. When we open RStudio initially, our console will usually look something like this:\nR version 4.3.1 (2023-06-16 ucrt) -- \"Beagle Scouts\"\nCopyright (C) 2023 The R Foundation for Statistical Computing\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nType 'demo()' for some demos, 'help()' for on-line help, or\n'help.start()' for an HTML browser interface to help.\nType 'q()' to quit R.\n\n&gt; \nNotice that at the bottom, there is a single line beginning with &gt;. This is the R console’s command prompt, and it is where we type our commands. We then press Enter, and our command is executed. The output of the command, if any, is displayed on the next line or lines, and then a new &gt; prompt appears.\nWhile R is much more than a simple calculator, a useful way to familiarize yourself with R and the console is to do some simple calculator-like computations. Most of this will work just like you would expect from a typical calculator.\nFirst, click into the console with your mouse, type 10 + 5 into your console and press Enter/Return ↵ on your keyboard. The result should be pretty obvious. Now, type 6 * 15 into your console and press Enter/Return ↵ on your keyboard. Next, type sqrt(25) into your console and press Enter/Return ↵ on your keyboard. This last example demonstrates how functions are called within R. The code sqrt() calls the square root function in R and asks R to compute the square root of the number provided within the parentheses. Now, type calc1 &lt;- sqrt(25) into your console and hit Enter/Return. This time R does not return a value but instead has stored the value in memory by assigning it to a variable. We do this with the assignment operator &lt;-, which is a &lt; symbol followed directly by a - symbol. The &lt;- can be typed by key combination Alt+- (i.e Alt key and minus key together) or Option+- on the Mac. This object is now listed in your Environment pane. Type calc1 into your console and press Enter/Return ↵ on your keyboard, to print the value saved in the object. Quick Note: In the previous commands, we put a space between around the +, *, &lt;- operators. This is a matter of recommended style to improve readability, not a requirement.\n\n\n\n\n\n\nBroom to the Rescue\n\n\n\nIn the top right of the console pane, you will find a symbol that looks like a broom. This is quite an important icon because it clears your console. Sometimes the console can become very cluttered and difficult to read. When you want to declutter your console, click the broom icon and clear the console of all text. I use it so frequently that I strongly recommend learning the keyboard shortcut, which is Ctrl + L on PC and Mac.\n\n\n\n\n\nRather than typing R commands into the Console, we typically write short programs, known as “R scripts” that contain the R commands that we wish to execute. This allows for reproducibility because everytime you run your R script you’ll get the same result (assuming the input is the same) or you could give your script to someone else and they’ll get the same result as well.\nTo create a new R Script, select File, then New File, then R Script from the RStudio menu. A file editor tab will open in the Source panel. R code can be entered here, and buttons and menu items are provided to run all the code (called sourcing the file) or to run the code on a single line or in a selected section of the file.\n\n\n\n\n\nCreating a new R Script.\n\n\n\n\nNext, type the following three lines of commands into your R script or copy and paste the code into your R script and update the code with your responses:\n\n\n\nType the code in the R Script file. Ignore the numbers listed to the left of the code.\n\nmyname &lt;- \"Your Name\"   \nmyfavfood &lt;- \"Name of your Favorite Food\"  \npaste(\"My name is\", myname, \"and I really like to eat\", myfavfood)\n\n\nYou may now run each line of your script by clicking on the RUN button, or by pressing the Ctrl + Enter (Cmd + Enter for Macs) keys simultaneously. Notice that R will continue to provide the output in the console, but pressing Enter by itself doesn’t make R run any command.\nLet’s save your first R script. Select File, then Save to give your script a name and save it in your working directory. Congratulations! You have created and saved your first R Script file."
  },
  {
    "objectID": "new.html#sec-packages",
    "href": "new.html#sec-packages",
    "title": "Tutorial #1",
    "section": "",
    "text": "When you install R you will have access to a range of functions including options for data wrangling and statistical analysis. The functions that are included in the default installation are typically referred to as “base R” and you can think of them like the default apps that come pre-loaded on your phone.\nOne of the great things about R, however, is that it is user extensible: anyone can create a new add-on that extends its functionality. There are currently thousands of packages that R users have created to solve many different kinds of problems, or just simply to have fun. For example, there are packages for data visualization, machine learning, interactive dashboards, web scraping, and playing games such as Sudoku.\nAdd-on packages are not distributed with base R, but have to be downloaded and installed from an archive, in the same way that you would, for instance, download and install PokemonGo on your smartphone. The main repository where packages reside is called CRAN`, the Comprehensive R Archive Network.\nThere is an important distinction between installing a package and loading a package.\n\n\nThis is done using the function install.packages(). This is like installing an app on your phone: you only have to do it once and the app will remain installed until you remove it. For instance, if you want to use PokemonGo on your phone, you install it once from the App Store or Play Store; you don’t have to re-install it each time you want to use it. Once you launch the app, it will run in the background until you close it or restart your phone. Likewise, when you install a package, the package will be available (but not loaded) every time you open up R.\nInstall the dslabs package on your system. This package contains 26 different datasets and we will explore some of these datasets over the next few weeks.\n\n\n\nRun in the console\n\n#Type the code below in the console. Ignore the number listed to the left of the code.\ninstall.packages(\"dslabs\")\n\n\n\n\n\n\n\n\nInstall packages from the console only\n\n\n\nNever install a package from inside a script. Only do this from the console pane or the packages tab of the lower right pane.\n\n\nHere are some other packages you’ll want to install for the first two chapters.\n\n\n\nRun in the console\n\n#Type the code below in the console. Ignore the number listed to the left of the code.\ninstall.packages(\"beepr\") # for beeps\ninstall.packages(\"rmarkdown\") # for creating R markdown files\ninstall.packages(\"devtools\")  # for installing packages from github\n\n\nThe hash (#) marks everything to the right of it as comment. Using comments can be very useful for annotating your code, and it improves the readability too. It will also help you to remember why/what you done months later, when you return to your code that you have inevitably forgotten!\nOnce you’ve installed the devtools package, you can also install packages from repositories other than CRAN, such as github. The following code installs the development version of a package for making waffle plots.\n\n\n\nRun in the console\n\n# install waffle package. Ignore the number listed to the left of the code.\ndevtools::install_github(\"hrbrmstr/waffle\")\n\n\n\n\n\nThis is done using the library() function. This is like launching an app on your phone: the functionality is only there when the app is launched and remains there until you close the app or restart RStudio. For example, when you run library(devtools) within a session, the functions in the package referred to by devtools will be made available for your R session. The next time you start RStudio, you will need to run library(devtools) again if you want to access that package.\nAfter installing the beepr package, you can load it for your current R session as follows:\n\n\n\nRun in the console\n\nlibrary(beepr)\n\n\nYou might get some red text when you load a package, this is normal. It is usually warning you that this package has functions that have the same name as other packages you’ve already loaded.\n\n\n\n\n\n\nNote\n\n\n\nYou can use the convention package::function() to indicate in which add-on package a function resides. For instance, if you see readr::read_csv(), that refers to the function read_csv() in the {readr} add-on package. If the package is loaded using library(), you don’t have to specify the package name before a function unless there is a conflict (e.g., you have two packages loaded that have a function with the same name).\n\n\n\n\n\nNow you can run the function beep().\n\n\n\nRun in the console\n\nbeep()\n\n\nA function is a name that refers to some code you can reuse. We’ll start by using functions that are provided for you in packages, but you can also write your own functions. After the function name, there is a pair of parentheses, which contain zero or more arguments. These are options that you can set. In the example above, the sound argument has a default value of 1, which makes a “ping” sound. Try changing the argument to an integer between 1 and 11.\n\n\n\nRun in the console\n\nbeep(sound = 8)\n\n\n\n\n\nWe have pre-installed the course workspace with the package tidyverse. This is the main package we will use throughout this course for data wrangling, summaries, and visualization.\ntidyverse is a meta-package that loads several packages we’ll be using in almost every chapter in this book:\n\nggplot2, for data visualisation (?@sec-viz)\nreadr, for data import (?@sec-data)\ntibble, for tables (?@sec-data)\ntidyr, for data tidying (?@sec-tidy)\ndplyr, for data manipulation (?@sec-wrangle)\nstringr, for string data\nforcats, for categorical data\npurrr, for repeating things\n\nWhen you install tidyverse, it also installs some other useful packages that you can load individually. You can get the full list using tidyverse_packages(), but the packages we’ll be using in this book are:\n\ngooglesheets4, for working with Google spreadsheets\nreadxl, for Excel files\nlubridate, for working with dates\nhms, for working with times\nrvest, for web scraping\n\n\n\n\nWhen you load the tidyverse it automatically loads all of the above packages, however, it can be helpful to know which package a function comes from if you need to Google it.\nIf the package isn’t loaded, use ?package_name::function_name or specify the package in the help() function. When you aren’t sure what package the function is in, use the shortcut ??function_name.\n\n\n\nRun in the console\n\n# if the package is loaded\n?beepr\nhelp(\"beepr\")\n\n# works whether or not the package is loaded\n?beepr::beep\nhelp(\"beep\", package=\"beepr\") \n\n# shows a list of potentially matching functions\n??beep"
  },
  {
    "objectID": "new.html#sec-intro-customize",
    "href": "new.html#sec-intro-customize",
    "title": "Tutorial #1",
    "section": "",
    "text": "You can customize how RStudio looks to make it work for you. For example, you can adjust the size of the panes by moving the gray lines which separate the four panes. The panes can be minimized or maximized using the icons on the right side of the gray bar at the the top of each pane. You also can change the location of panes and what tabs are shown under Tools &gt; Global Options… &gt; Pane Layout.\nMore importantly, you can change the default font, font size, and general appearance of R Studio, including it’s color scheme. Click Tools &gt; Global Options &gt; Appearance. Play around with the settings and see what you prefer - you’re going to spend a lot of time with RStudio, it might as well look nice!\n\n\n\n\n\n\n\nOver the semester, you will be learning how to make reproducible reports using rmarkdown. This involves writing scripts that transform data, create summaries and visualizations, and embed them in a report in a way that always provides the same results. We will go into more details about RMarkdown in the next tutorial.\nWhen you do things reproducibly, others (and most importantly future you) can understand and check your work. You can also reuse your work more easily. For example, if you need to create a report every month with the social media analytics for your company, a reproducible report allows you to download a new month’s data and create the report within seconds. It might take a little longer to set up the report in the first instance with reproducible methods, but the time it saves you in the long run is invaluable.\nhttps://bookdown.org/daniel_dauber_io/r4np_book/setting-up-r-and-rstudio.html#when-you-first-start-rstudio\nWe recommend that you make the following changes to your RStudio settings to set yourself up for success right from the beginning. To open the Rstudio settings you have to click on\nRStudio &gt; Tools &gt; Global Options or press ⌘ + , if you are on a Mac.\nRStudio &gt; Tools &gt; Global Options or press Ctrl + , if you work on a Windows computer.\n\n\n\n\n\nOn the first tab, i.e. General &gt; Basic, we should make one of the most significant changes. Deactivate every option that starts with Restore. This will ensure that every time you start RStudio, you begin with a clean slate. At first sight, it might sound counter-intuitive not to restart everything where you left off, but it is essential to make all your projects easily reproducible. Furthermore, if you work together with others, not restoring your personal settings also ensures that your programming works across different computers. Therefore, I recommend having the following unticked:\nRestore most recently opened project at startup,\nRestore previously open source documents at startup,\nRestore .Rdata into workspace at startup\nIn the same tab under Workspace, select Never for the setting Save workspace to .RData on exit. One might think it is wise to keep intermediary results stored from one R session to another. However, I often found myself fixing issues due to this lazy method, and my code became less reliable and, therefore, reproducible. With experience, you will find that this avoids many headaches.\nIn the Code &gt; Editing tab, make sure to have at least the first five options ticked, especially the Auto-indent code after paste. This setting will save time when trying to format your coding appropriately, making it easier to read. Indentation is the primary way of making your code look more readable and less like a series of characters that appear almost random.\n\n\n\n\n\n\n\n\nIf you have the above settings configured correctly, when you open up RStudio and start writing code, loading packages, and creating objects, you will be doing so in a new session and your Environment tab should be completely empty. If you find that your code isn’t working and you can’t figure out why, it might be worth restarting your R session. This will clear the environment and detach all loaded packages - think of it like restarting your phone. There are several ways that you can restart R:\n\nMenu: Session &gt; Restart R\nCmd-Shift-F10 or Ctl-Shift-F10\ntype .rs.restartR() in the console\n\nTry doing each of these now. Additionally, doing so prior to running any new R script is good practice because it ensures that our script will not have any hidden dependencies, and that any data structures or functions that the code does depend on are created from the code contained in the script."
  },
  {
    "objectID": "new.html#footnotes",
    "href": "new.html#footnotes",
    "title": "Tutorial #1",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://www.rstudio.com/resources/cheatsheets/↩︎"
  },
  {
    "objectID": "Tutorial#2.html",
    "href": "Tutorial#2.html",
    "title": "Tutorial#2",
    "section": "",
    "text": "In this course, we will be using the R software environment for all our analysis. You will learn R and data analysis techniques simultaneously. This tutorial introduces some basic programming concepts and terminology. Instead of asking you to memorize all these concepts and terminology right now, we will guide you so that you will “learn by doing.” To help you learn, we will always use a different font to distinguish regular text from computer_code. In this tutorial, we will review the difference between objects and functions, arithmetic and logical operators, the most common data types in R, and explore a simple dataset. The best way to master these topics is, in our opinions, through deliberate practice with R and lots of repetition.\n\n\n* Be able to explain the difference between a data object and a function.\n* Be familiar with the common types of data and data structures in R.\n* Understand how and when to use arithmetic and logical operators in R.\n* Be able to explore a dataset using basic Base R functions.\n\n\n\nIn R, we first need to grasp the notions of objects and functions. From a task-oriented perspective, using R consists of\n\ncreating or loading data (inputs, material, values), and\ncalling or evaluating functions (commands, actions, verbs) for\ncomputing and constructing new data (outputs, images, tables, results).\n\nConfusingly, both data and functions in R are objects (stuff) and evaluating functions typically returns or creates new objects (more stuff). Thus, the process of computation can be viewed as a cycle that uses data (as input) to create more data (as output). Although any part of a program is an object, functions are those objects that do things by processing or performing tasks on data and create new objects. To distinguish data from functions, think of data as matter (i.e., material, stuff, or values) that are being measured, manipulated, or processed, and of functions as procedures (i.e., actions, operations, or verbs) that measure, manipulate, or process data. Put more succinctly, functions are objects that do things — they process data into other data.\nAlthough this tutorial addresses data and functions in the context of base R, the same distinctions also apply to other packages and languages. In the following, we will introduce some ways to describe data (by type and shape), learn to create new data objects (by assigning them with &lt;-), and apply some pre-defined functions to these data objects. [and to create new data objects?]\n\n\n\n\n\n\nR Notation\n\n\n\nTo make it easier to distinguish between data objects and functions, we will typically add (round) parentheses to function names. Thus, abc() indicates a function, whereas abc indicates a data object. However, keep in mind that there are some R functions that work without parentheses (e.g., arithmetic operators + and * that are positioned between their arguments).\n\n\n\n\n\nFunctions, also called commands, perform tasks in R. They take in inputs called arguments and return outputs. Most functions require the user to manually specify a function’s arguments. For example, if type sqrt() and press Enter/Return, you will get an error message. There are some functions for which the user can either manually specify a function’s arguments or use the function’s default values. For example, the function seq() in R generates a sequence of numbers. If you just run seq() it will return the value 1. That doesn’t seem very useful! This is because the default arguments are set as seq(from = 1, to = 1). Thus, if you don’t pass in different input values for from and to to change this behavior, R just assumes all you want is the number 1. You can change the argument values by updating the values after the = sign. If we try out seq(from = 2, to = 5) or alternatively seq(2:5), we will get the result 2 3 4 5 that we might expect.\nOver the semester you will get lots of practice working with functions and understanding their behaviors. In addition to the sqrt() and the seq() functions, we have also used the install.packages() and the library() functions. There are thousands of functions built into R and even more can be added through packages. These functions do not appear in the workspace because you did not define them, but they are available for immediate use.\n\n\n\nWhen formally dealing with data, it makes sense to distinguish between a variable and its values: A variable is a dimension or property that describes a unit of observation (e.g., a person, a school, a country, etc.) and can typically assume different values. By contrast, values are the concrete instantiations that a variable assigns to every unit of observation and are further characterized by their range (e.g., categorical vs. continuous values) and their type (e.g., numeric, character, or logical values). For instance, an individual can be characterized by the variables name, age, and whether or not they are classified as an adult. The values corresponding to these variables would be of type text (e.g., “Lisa”), numeric (e.g., 16, age in years), and logical (TRUE vs. FALSE, defined as a function of age).\n\n\nTo make the best out of the R programming language, a programmer needs a strong understanding of the basic data types and data structures, and how to operate on them.\nIn R, data is stored in objects that are distinguished by their type and by their shape:\n\nThe most common types of data are:\n\ndoubles - for representing all real numbers (whole numbers and decimals, such as -55, 0.75, 5);\nintegers - for representing only whole numbers (such as -1, 0, 85, 2568);\ncharacters - for representing text or string data (such as “apple”, “laywer”);\nlogicals - for representing a variable with only truth values of type logical TRUE or FALSE (aka. Boolean values);\ntime - for representing dates and times;\n\nOther important data type in R include:\n\nNA - Missing values;\nNaN - Not a Number e.g. sqrt(-4);\nInf - Infinite values e.g. 5/0.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNote that R distinguishes between two numeric data types (integer and double). It defaults to storing numerical data as double. You need to add a L after the number to tell R you want the number stored as an integer or use the function as.integer(). Keep in mind that unless you tell R something is an integer, it will store it as double. This default behavior is helpful since we will mostly be working with doubles, not integers. In general, you can ignore this distinction but occasionally it comes up so it is good to know it exists. Also note that character data type is declared by enclosing it in double quotation marks. Similarly, R will treat numerical data with double quotation marks as character (text/string) data (e.g., “432.5”).\n\n\n\n\n\nhttps://rpubs.com/STEMResearch/data-types-in-r\nThere are two functions, typeof() and class(), that can be applied to any R object to check what type of data object it is. Data types can also be converted from one type to another using the as._____ functions.\nThe function typeof() can be applied to any R object to check what type of data object it is. Data types can also be converted from one type to another using the as._____ functions.\n\n\n\nFunction\nDescription\n\n\n\n\nas.double()\nConvert to double\n\n\nas.integer()\nConvert to integer\n\n\nas.numeric()\nConvert to numeric\n\n\nas.character()\nConvert to character\n\n\nas.logical()\nConvert to logical\n\n\nas.complex()\nConvert to complex\n\n\n\n\n\n\nhttps://bookdown.org/rwnahhas/IntroToR/object-types.html\nThe shape of an object mostly depends on its structure. A clear understanding of R data structures is crucial since these are the objects you will manipulate on a day-to-day basis in R.\nThe most common shapes of data are:\n\nscalars are individual elements (e.g., “A”, 4, TRUE);\nvectors are linear chains or sequences of objects (can be either numeric or character but not both);\ntables are rectangular data structures with two dimensions (with rows and columns).\n\nThere are additional data shapes (e.g., multi-dimensional data structures) and types (e.g., for representing categorical or geographical data), but the ones mentioned here are the ones that we will be focusing on in DSCI 100.\n\n\n\nThe main type of object used in R for representing data is a vector. A vector is a column of numbers or character strings indexed by the integers 1, 2, …, n, where n is the length of the vector. Vectors come in different data types and shapes. They can be either numeric or character but not both. If you attempt to create a vector with both numeric values and character strings, R will convert the numeric values to character.\nWe create a vector of numbers and display it like this:\n\n# this creates a vector of heights, in cm\nheights &lt;- c(203, 148, 156, 158, 167)\n\nThe c() command is shorthand for combine or concatenate, so in the example above we are combining the individual elements (the 5 numbers) into a new vector that is assigned the label heights using &lt;-, the assignment operator. And we can check the values stored in the variable by asking R to print them. You can either type print(heights), or just write the name of the variable alone heights, which will print it by default.\nWe can also create a vector of text elements:\n\n# this creates a vector of text \nnames &lt;- c(\"Ben\", \"Rosa\", \"Sue\", \"Joe\", \"Lucia\")\n\nThe quotes around “Ben”, “Rosa”, etc. are essential here. Without the quotes R will assume there are objects called Ben, Rosa, etc. in the workspace. As these objects don’t exist in R’s memory, there will be an error message.\nNote: If you are using RStudio, they will be stored in our environment located in the top right window.\nWhen simultaneously considering the shape and type of data, we can distinguish and begin to understand data structures.\n\n\n\nData structures are constructs designed to store data. As we mentioned in Section 1.1.3, the data structures of a programming language are similar to the grammatical and spelling rules of natural languages. As long as we reach our goals, we neither care about nor need to know the rules. But whenever unexpected outcomes or errors occur, repairing them in a competent fashion requires considerable background knowledge and experience.\nAlthough the term “data structure” is sometimes used to refer to just the shape of data, understanding the key data structures available in R requires viewing them as a combination of (a) some data shape, and (b) the fact whether they contain a single or multiple types of data.\nThe table below provides an overview of the key data structures provided by the designers of R. Note that we distinguishe between three different data shapes (in its rows) and between data structures for “homogeneous” vs. “heterogeneous” data types (in its columns):\n\n\n\nFunction\nDescription\n\n\n\n\nas.double()\nConvert to double\n\n\nas.integer()\nConvert to integer\n\n\nas.numeric()\nConvert to numeric\n\n\nas.character()\nConvert to character\n\n\nas.logical()\nConvert to logical\n\n\nas.complex()\nConvert to complex\n\n\n\n\n\n\n\nThe most basic computation you can do in R is arithmetic operations. In other words, addition, subtraction, multiplication, division, exponentiation and extraction of roots. In short, R can be used like your pocket calculator, or more likely the one you have on your phone. We demonstrated this in Tutorial #1 when we performed some simple computations. As with many calculators, the operators are + for addition, - for subtraction, * for multiplication, / for division and ^ for exponentiation. Often parentheses are used to clarify the order of operations.\n\n\n\nFunction\nDescription\n\n\n\n\n+\naddition\n\n\n-\nsubtraction\n\n\n*\nmultiplication\n\n\n/\ndivision\n\n\nabs()\nabsolute value\n\n\nx^n\nraise x to power of some number n\n\n\nsqrt()\nsquare root of a number or variable ( n^2 does same)\n\n\nlog()\nnatural log\n\n\nexp()\nantilog, exponent of variable or number\n\n\nlog2()\nlog of other bases, eg. log base 2\n\n\n\n\n\nThe main difference between arithmetic operators and logical operators is that logical operators are used to make comparisons and will yield a logical (TRUE/FALSE) output. These are really helpful when we want to identify certain qualities about the data.\nBelow is a list of some common logical operators that can be used on R:\n\n\n\nFunction\nDescription\n\n\n\n\n==\nis equal to\n\n\n!=\nis not equal to\n\n\n&lt;\nless than\n\n\n&gt;\ngreater than\n\n\n&lt;=\nless than or equal to\n\n\n&gt;=\ngreater than or equal to\n\n\n|\nor operator\n\n\n&\nand operator\n\n\n\nHere’s a helpful visual about logical operators, x is the left circle, y is the right circle.\n\nExamples of using logicals operators to test equality.\n\n# Examples:\n3 == 4 #FALSE, 3 is not equal to 4\n3 != 4 #TRUE, 3 is not equal to 4\n\n\"cat\" == \"cat\" #TRUE, this works with strings too \"cat\" is the same as \"cat\"\n\n\n\n\n\nLet’s put everything we’ve learned so far into practice and start exploring some real data! Data comes to us in a variety of formats, from pictures to text to numbers. Throughout this book, we’ll focus on datasets that are saved in “spreadsheet”-type format. This is probably the most common way data are collected and saved in many fields. Remember from Subsection 1.2.1 that these “spreadsheet”-type datasets are called data frames in R. We’ll focus on working with data saved as data frames throughout this book.\nLet’s first load all the packages needed for this chapter, assuming you’ve already installed them. Read Section 1.3 for information on how to install and load R packages if you haven’t already."
  },
  {
    "objectID": "Tutorial#2.html#sec-ilo-intro",
    "href": "Tutorial#2.html#sec-ilo-intro",
    "title": "Tutorial#2",
    "section": "",
    "text": "* Be able to explain the difference between a data object and a function.\n* Be familiar with the common types of data and data structures in R.\n* Understand how and when to use arithmetic and logical operators in R.\n* Be able to explore a dataset using basic Base R functions."
  },
  {
    "objectID": "Tutorial#2.html#sec-intro-basic_terms",
    "href": "Tutorial#2.html#sec-intro-basic_terms",
    "title": "Tutorial#2",
    "section": "",
    "text": "In R, we first need to grasp the notions of objects and functions. From a task-oriented perspective, using R consists of\n\ncreating or loading data (inputs, material, values), and\ncalling or evaluating functions (commands, actions, verbs) for\ncomputing and constructing new data (outputs, images, tables, results).\n\nConfusingly, both data and functions in R are objects (stuff) and evaluating functions typically returns or creates new objects (more stuff). Thus, the process of computation can be viewed as a cycle that uses data (as input) to create more data (as output). Although any part of a program is an object, functions are those objects that do things by processing or performing tasks on data and create new objects. To distinguish data from functions, think of data as matter (i.e., material, stuff, or values) that are being measured, manipulated, or processed, and of functions as procedures (i.e., actions, operations, or verbs) that measure, manipulate, or process data. Put more succinctly, functions are objects that do things — they process data into other data.\nAlthough this tutorial addresses data and functions in the context of base R, the same distinctions also apply to other packages and languages. In the following, we will introduce some ways to describe data (by type and shape), learn to create new data objects (by assigning them with &lt;-), and apply some pre-defined functions to these data objects. [and to create new data objects?]\n\n\n\n\n\n\nR Notation\n\n\n\nTo make it easier to distinguish between data objects and functions, we will typically add (round) parentheses to function names. Thus, abc() indicates a function, whereas abc indicates a data object. However, keep in mind that there are some R functions that work without parentheses (e.g., arithmetic operators + and * that are positioned between their arguments)."
  },
  {
    "objectID": "Tutorial#2.html#sec-intro-functions",
    "href": "Tutorial#2.html#sec-intro-functions",
    "title": "Tutorial#2",
    "section": "",
    "text": "Functions, also called commands, perform tasks in R. They take in inputs called arguments and return outputs. Most functions require the user to manually specify a function’s arguments. For example, if type sqrt() and press Enter/Return, you will get an error message. There are some functions for which the user can either manually specify a function’s arguments or use the function’s default values. For example, the function seq() in R generates a sequence of numbers. If you just run seq() it will return the value 1. That doesn’t seem very useful! This is because the default arguments are set as seq(from = 1, to = 1). Thus, if you don’t pass in different input values for from and to to change this behavior, R just assumes all you want is the number 1. You can change the argument values by updating the values after the = sign. If we try out seq(from = 2, to = 5) or alternatively seq(2:5), we will get the result 2 3 4 5 that we might expect.\nOver the semester you will get lots of practice working with functions and understanding their behaviors. In addition to the sqrt() and the seq() functions, we have also used the install.packages() and the library() functions. There are thousands of functions built into R and even more can be added through packages. These functions do not appear in the workspace because you did not define them, but they are available for immediate use."
  },
  {
    "objectID": "Tutorial#2.html#sec-intro-data",
    "href": "Tutorial#2.html#sec-intro-data",
    "title": "Tutorial#2",
    "section": "",
    "text": "When formally dealing with data, it makes sense to distinguish between a variable and its values: A variable is a dimension or property that describes a unit of observation (e.g., a person, a school, a country, etc.) and can typically assume different values. By contrast, values are the concrete instantiations that a variable assigns to every unit of observation and are further characterized by their range (e.g., categorical vs. continuous values) and their type (e.g., numeric, character, or logical values). For instance, an individual can be characterized by the variables name, age, and whether or not they are classified as an adult. The values corresponding to these variables would be of type text (e.g., “Lisa”), numeric (e.g., 16, age in years), and logical (TRUE vs. FALSE, defined as a function of age).\n\n\nTo make the best out of the R programming language, a programmer needs a strong understanding of the basic data types and data structures, and how to operate on them.\nIn R, data is stored in objects that are distinguished by their type and by their shape:\n\nThe most common types of data are:\n\ndoubles - for representing all real numbers (whole numbers and decimals, such as -55, 0.75, 5);\nintegers - for representing only whole numbers (such as -1, 0, 85, 2568);\ncharacters - for representing text or string data (such as “apple”, “laywer”);\nlogicals - for representing a variable with only truth values of type logical TRUE or FALSE (aka. Boolean values);\ntime - for representing dates and times;\n\nOther important data type in R include:\n\nNA - Missing values;\nNaN - Not a Number e.g. sqrt(-4);\nInf - Infinite values e.g. 5/0.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNote that R distinguishes between two numeric data types (integer and double). It defaults to storing numerical data as double. You need to add a L after the number to tell R you want the number stored as an integer or use the function as.integer(). Keep in mind that unless you tell R something is an integer, it will store it as double. This default behavior is helpful since we will mostly be working with doubles, not integers. In general, you can ignore this distinction but occasionally it comes up so it is good to know it exists. Also note that character data type is declared by enclosing it in double quotation marks. Similarly, R will treat numerical data with double quotation marks as character (text/string) data (e.g., “432.5”).\n\n\n\n\n\nhttps://rpubs.com/STEMResearch/data-types-in-r\nThere are two functions, typeof() and class(), that can be applied to any R object to check what type of data object it is. Data types can also be converted from one type to another using the as._____ functions.\nThe function typeof() can be applied to any R object to check what type of data object it is. Data types can also be converted from one type to another using the as._____ functions.\n\n\n\nFunction\nDescription\n\n\n\n\nas.double()\nConvert to double\n\n\nas.integer()\nConvert to integer\n\n\nas.numeric()\nConvert to numeric\n\n\nas.character()\nConvert to character\n\n\nas.logical()\nConvert to logical\n\n\nas.complex()\nConvert to complex\n\n\n\n\n\n\nhttps://bookdown.org/rwnahhas/IntroToR/object-types.html\nThe shape of an object mostly depends on its structure. A clear understanding of R data structures is crucial since these are the objects you will manipulate on a day-to-day basis in R.\nThe most common shapes of data are:\n\nscalars are individual elements (e.g., “A”, 4, TRUE);\nvectors are linear chains or sequences of objects (can be either numeric or character but not both);\ntables are rectangular data structures with two dimensions (with rows and columns).\n\nThere are additional data shapes (e.g., multi-dimensional data structures) and types (e.g., for representing categorical or geographical data), but the ones mentioned here are the ones that we will be focusing on in DSCI 100.\n\n\n\nThe main type of object used in R for representing data is a vector. A vector is a column of numbers or character strings indexed by the integers 1, 2, …, n, where n is the length of the vector. Vectors come in different data types and shapes. They can be either numeric or character but not both. If you attempt to create a vector with both numeric values and character strings, R will convert the numeric values to character.\nWe create a vector of numbers and display it like this:\n\n# this creates a vector of heights, in cm\nheights &lt;- c(203, 148, 156, 158, 167)\n\nThe c() command is shorthand for combine or concatenate, so in the example above we are combining the individual elements (the 5 numbers) into a new vector that is assigned the label heights using &lt;-, the assignment operator. And we can check the values stored in the variable by asking R to print them. You can either type print(heights), or just write the name of the variable alone heights, which will print it by default.\nWe can also create a vector of text elements:\n\n# this creates a vector of text \nnames &lt;- c(\"Ben\", \"Rosa\", \"Sue\", \"Joe\", \"Lucia\")\n\nThe quotes around “Ben”, “Rosa”, etc. are essential here. Without the quotes R will assume there are objects called Ben, Rosa, etc. in the workspace. As these objects don’t exist in R’s memory, there will be an error message.\nNote: If you are using RStudio, they will be stored in our environment located in the top right window.\nWhen simultaneously considering the shape and type of data, we can distinguish and begin to understand data structures.\n\n\n\nData structures are constructs designed to store data. As we mentioned in Section 1.1.3, the data structures of a programming language are similar to the grammatical and spelling rules of natural languages. As long as we reach our goals, we neither care about nor need to know the rules. But whenever unexpected outcomes or errors occur, repairing them in a competent fashion requires considerable background knowledge and experience.\nAlthough the term “data structure” is sometimes used to refer to just the shape of data, understanding the key data structures available in R requires viewing them as a combination of (a) some data shape, and (b) the fact whether they contain a single or multiple types of data.\nThe table below provides an overview of the key data structures provided by the designers of R. Note that we distinguishe between three different data shapes (in its rows) and between data structures for “homogeneous” vs. “heterogeneous” data types (in its columns):\n\n\n\nFunction\nDescription\n\n\n\n\nas.double()\nConvert to double\n\n\nas.integer()\nConvert to integer\n\n\nas.numeric()\nConvert to numeric\n\n\nas.character()\nConvert to character\n\n\nas.logical()\nConvert to logical\n\n\nas.complex()\nConvert to complex"
  },
  {
    "objectID": "Tutorial#2.html#sec-intro-operations",
    "href": "Tutorial#2.html#sec-intro-operations",
    "title": "Tutorial#2",
    "section": "",
    "text": "The most basic computation you can do in R is arithmetic operations. In other words, addition, subtraction, multiplication, division, exponentiation and extraction of roots. In short, R can be used like your pocket calculator, or more likely the one you have on your phone. We demonstrated this in Tutorial #1 when we performed some simple computations. As with many calculators, the operators are + for addition, - for subtraction, * for multiplication, / for division and ^ for exponentiation. Often parentheses are used to clarify the order of operations.\n\n\n\nFunction\nDescription\n\n\n\n\n+\naddition\n\n\n-\nsubtraction\n\n\n*\nmultiplication\n\n\n/\ndivision\n\n\nabs()\nabsolute value\n\n\nx^n\nraise x to power of some number n\n\n\nsqrt()\nsquare root of a number or variable ( n^2 does same)\n\n\nlog()\nnatural log\n\n\nexp()\nantilog, exponent of variable or number\n\n\nlog2()\nlog of other bases, eg. log base 2\n\n\n\n\n\nThe main difference between arithmetic operators and logical operators is that logical operators are used to make comparisons and will yield a logical (TRUE/FALSE) output. These are really helpful when we want to identify certain qualities about the data.\nBelow is a list of some common logical operators that can be used on R:\n\n\n\nFunction\nDescription\n\n\n\n\n==\nis equal to\n\n\n!=\nis not equal to\n\n\n&lt;\nless than\n\n\n&gt;\ngreater than\n\n\n&lt;=\nless than or equal to\n\n\n&gt;=\ngreater than or equal to\n\n\n|\nor operator\n\n\n&\nand operator\n\n\n\nHere’s a helpful visual about logical operators, x is the left circle, y is the right circle.\n\nExamples of using logicals operators to test equality.\n\n# Examples:\n3 == 4 #FALSE, 3 is not equal to 4\n3 != 4 #TRUE, 3 is not equal to 4\n\n\"cat\" == \"cat\" #TRUE, this works with strings too \"cat\" is the same as \"cat\""
  },
  {
    "objectID": "Tutorial#2.html#sec-intro-explore_dataset",
    "href": "Tutorial#2.html#sec-intro-explore_dataset",
    "title": "Tutorial#2",
    "section": "",
    "text": "Let’s put everything we’ve learned so far into practice and start exploring some real data! Data comes to us in a variety of formats, from pictures to text to numbers. Throughout this book, we’ll focus on datasets that are saved in “spreadsheet”-type format. This is probably the most common way data are collected and saved in many fields. Remember from Subsection 1.2.1 that these “spreadsheet”-type datasets are called data frames in R. We’ll focus on working with data saved as data frames throughout this book.\nLet’s first load all the packages needed for this chapter, assuming you’ve already installed them. Read Section 1.3 for information on how to install and load R packages if you haven’t already."
  },
  {
    "objectID": "tutorial3.html",
    "href": "tutorial3.html",
    "title": "Tutorial #3",
    "section": "",
    "text": "In the previous two tutorials, we briefly reviewed how to write code in the R console and in R scripts. This tutorial focuses on using RMarkdown to produce rich, fully-documented, reproducible analyses. We will also cover how to set up your working environment, mathematical and logical operators, the most common data types in R, explore a simple dataset, write an R function as well as how to seek for help within and outside of R.\n\n\n* Be able to create and knit an RMarkdown file.\n* Be able to recognize and correct Common Errors from R\n* Understand Coding Etiquette\n\n\n\nR Markdown is a flexible type of document that allows you to seamlessly combine executable R code, and its output, with text in a single document. These documents can be easily converted to multiple static and dynamic output formats, including PDF (.pdf), Word (.docx), and HTML (.html).\nThe benefit of a well-prepared R Markdown document is full reproducibility. It allows users to share a single file containing all of the comments, R code, and metadata needed to reproduce the analysis from beginning to end. This also means that, if you notice any errors, or you need to add more data to your analysis, you will be able to recompile the report without making any changes in the actual document.\n\n\n\n\n\nImage credit: Alison Horst (https://allisonhorst.com/).\n\n\n\n\nThe rmarkdown package comes pre-installed with RStudio, so no action is necessary. We think you will be pleasantly surprised at how easy it is to write an RMarkdown document once you get the hang of it.\n\n\n\n\n\n\nRMarkdown Resources\n\n\n\nIn this tutorial, we provide brief instructions for creating a RMarkdown file. A more in-depth explanation of RMarkdown is here: https://rmarkdown.rstudio.com, and a more detailed user guide is here: https://rmarkdown.rstudio.com/lesson-1.html.\n\n\nSEE https://datacarpentry.org/r-socialsci/06-rmarkdown.html for RMarkdown details - CC4\nA typical R Markdown document consists of three distinct parts:\nA header for setting global document options;\nText that may contain headings, paragraphs, and itemized lists; and\nCode chunks that contain and evaluate R code.\nFortunately, the range of commands required to benefit from R Markdown is very limited. For instance, the commands in the help file Help &gt; Markdown Quick Reference of RStudio provide a good start for creating beautiful and functional documents. Beyond these basics, the R Markdown Cheatsheet — also available in RStudio by selecting Help &gt; Cheatsheets &gt; R Markdown Cheat Sheet — provides a more comprehensive overview of R Markdown functionality and commands:\nKnitting an R Markdown file causes all the R code to be run and the output from the code is put into a markdown file. The markdown file is then run to format the final document, this includes formatting the R code results. This all happens behind the scene. The working directory for these session is the folder that contains the R Markdown file.\nThe chunks of code are where most of your development and testing time will be spent. All the code in chunk can be run using the Run Current Chunk button, a green triangle at the top right of the code chunk. All chunk before the current chunk using the Run All Chunks Above button, The gray triangle pointing down that is just to the left of Run Current Chunk button. Part of the code in a chunk can be run using the run drop down menu on the tool bar at the top of the source page."
  },
  {
    "objectID": "tutorial3.html#sec-ilo-intro",
    "href": "tutorial3.html#sec-ilo-intro",
    "title": "Tutorial #3",
    "section": "",
    "text": "* Be able to create and knit an RMarkdown file.\n* Be able to recognize and correct Common Errors from R\n* Understand Coding Etiquette"
  },
  {
    "objectID": "tutorial3.html#sec-ilo-rmarkdown",
    "href": "tutorial3.html#sec-ilo-rmarkdown",
    "title": "Tutorial #3",
    "section": "",
    "text": "R Markdown is a flexible type of document that allows you to seamlessly combine executable R code, and its output, with text in a single document. These documents can be easily converted to multiple static and dynamic output formats, including PDF (.pdf), Word (.docx), and HTML (.html).\nThe benefit of a well-prepared R Markdown document is full reproducibility. It allows users to share a single file containing all of the comments, R code, and metadata needed to reproduce the analysis from beginning to end. This also means that, if you notice any errors, or you need to add more data to your analysis, you will be able to recompile the report without making any changes in the actual document.\n\n\n\n\n\nImage credit: Alison Horst (https://allisonhorst.com/).\n\n\n\n\nThe rmarkdown package comes pre-installed with RStudio, so no action is necessary. We think you will be pleasantly surprised at how easy it is to write an RMarkdown document once you get the hang of it.\n\n\n\n\n\n\nRMarkdown Resources\n\n\n\nIn this tutorial, we provide brief instructions for creating a RMarkdown file. A more in-depth explanation of RMarkdown is here: https://rmarkdown.rstudio.com, and a more detailed user guide is here: https://rmarkdown.rstudio.com/lesson-1.html.\n\n\nSEE https://datacarpentry.org/r-socialsci/06-rmarkdown.html for RMarkdown details - CC4\nA typical R Markdown document consists of three distinct parts:\nA header for setting global document options;\nText that may contain headings, paragraphs, and itemized lists; and\nCode chunks that contain and evaluate R code.\nFortunately, the range of commands required to benefit from R Markdown is very limited. For instance, the commands in the help file Help &gt; Markdown Quick Reference of RStudio provide a good start for creating beautiful and functional documents. Beyond these basics, the R Markdown Cheatsheet — also available in RStudio by selecting Help &gt; Cheatsheets &gt; R Markdown Cheat Sheet — provides a more comprehensive overview of R Markdown functionality and commands:\nKnitting an R Markdown file causes all the R code to be run and the output from the code is put into a markdown file. The markdown file is then run to format the final document, this includes formatting the R code results. This all happens behind the scene. The working directory for these session is the folder that contains the R Markdown file.\nThe chunks of code are where most of your development and testing time will be spent. All the code in chunk can be run using the Run Current Chunk button, a green triangle at the top right of the code chunk. All chunk before the current chunk using the Run All Chunks Above button, The gray triangle pointing down that is just to the left of Run Current Chunk button. Part of the code in a chunk can be run using the run drop down menu on the tool bar at the top of the source page."
  },
  {
    "objectID": "tutorial4.html",
    "href": "tutorial4.html",
    "title": "tutorial4.qmd",
    "section": "",
    "text": "#Type the code below in the console. Ignore the number listed to the left of the code.\n* Be able to explore a dataset using basic Base R functions.\n* Be able to recognize and correct Common Errors from R\n* Understand Coding Etiquette\n\n\nOne thing that intimidates new R and RStudio users is how it reports errors, warnings, and messages. R reports errors, warnings, and messages in a glaring red font, which makes it seem like it is scolding you. However, seeing red text in the console is not always bad.\nR will show red text in the console pane in three different situations:\nErrors: When the red text is a legitimate error, it will be prefaced with “Error in…” and will try to explain what went wrong. Generally when there’s an error, the code will not run. For example, we’ll see in Subsection 1.3.3 if you see Error in ggplot(…) : could not find function “ggplot”, it means that the ggplot() function is not accessible because the package that contains the function (ggplot2) was not loaded with library(ggplot2). Thus you cannot use the ggplot() function without the ggplot2 package being loaded first. Warnings: When the red text is a warning, it will be prefaced with “Warning:” and R will try to explain why there’s a warning. Generally your code will still work, but with some caveats. For example, you will see in Chapter 2 if you create a scatterplot based on a dataset where two of the rows of data have missing entries that would be needed to create points in the scatterplot, you will see this warning: Warning: Removed 2 rows containing missing values (geom_point). R will still produce the scatterplot with all the remaining non-missing values, but it is warning you that two of the points aren’t there. Messages: When the red text doesn’t start with either “Error” or “Warning”, it’s just a friendly message. You’ll see these messages when you load R packages in the upcoming Subsection 1.3.2 or when you read data saved in spreadsheet files with the read_csv() function as you’ll see in Chapter 4. These are helpful diagnostic messages and they don’t stop your code from working. Additionally, you’ll see these messages when you install packages too using install.packages() as discussed in Subsection 1.3.1. Remember, when you see red text in the console, don’t panic. It doesn’t necessarily mean anything is wrong. Rather:\nIf the text starts with “Error”, figure out what’s causing it. Think of errors as a red traffic light: something is wrong! If the text starts with “Warning”, figure out if it’s something to worry about. For instance, if you get a warning about missing values in a scatterplot and you know there are missing values, you’re fine. If that’s surprising, look at your data and see what’s missing. Think of warnings as a yellow traffic light: everything is working fine, but watch out/pay attention. Otherwise, the text is just a message. Read it, wave back at R, and thank it for talking to you. Think of messages as a green traffic light: everything is working fine and keep on going!\n\n\n\nLearning to code/program is quite similar to learning a foreign language. It can be daunting and frustrating at first. Such frustrations are common and it is normal to feel discouraged as you learn. However, just as with learning a foreign language, if you put in the effort and are not afraid to make mistakes, anybody can learn and improve.\nHere are a few useful tips to keep in mind as you learn to program:\nRemember that computers are not actually that smart: You may think your computer or smartphone is “smart,” but really people spent a lot of time and energy designing them to appear “smart.” In reality, you have to tell a computer everything it needs to do. Furthermore, the instructions you give your computer can’t have any mistakes in them, nor can they be ambiguous in any way. Take the “copy, paste, and tweak” approach: Especially when you learn your first programming language or you need to understand particularly complicated code, it is often much easier to take existing code that you know works and modify it to suit your ends. This is as opposed to trying to type out the code from scratch. We call this the “copy, paste, and tweak” approach. So early on, we suggest not trying to write code from memory, but rather take existing examples we have provided you, then copy, paste, and tweak them to suit your goals. After you start feeling more confident, you can slowly move away from this approach and write code from scratch. Think of the “copy, paste, and tweak” approach as training wheels for a child learning to ride a bike. After getting comfortable, they won’t need them anymore. The best way to learn to code is by doing: Rather than learning to code for its own sake, we find that learning to code goes much smoother when you have a goal in mind or when you are working on a particular project, like analyzing data that you are interested in and that is important to you. Practice is key: Just as the only method to improve your foreign language skills is through lots of practice and speaking, the only method to improving your coding skills is through lots of practice. Don’t worry, however, we’ll give you plenty of opportunities to do so!\n\n\n\nEverything that exists in R must be represented somehow. A generic term for something that we know not much about is an object. In R, we can distinguish between two main types of objects:\n\ndata objects are typically passive containers for values (e.g., numbers, truth values, or strings of text), whereas\nfunction objects are active elements or tools: They do things with data.\n\nMastering R (or any other programming language) essentially consists of solving two inter-related tasks:\n\nRepresenting various types of data as objects.\nManipulating those objects by using functions.\n\nFor any data object, we distinguish between its type and its shape. The shape of an object mostly depends on its structure. As this chapter uses only a single data structure (i.e., vectors), we will address issues of data shape later (in Chapter 3 on Data structures).\nHere, we focus on data types (which are also described as data modes in R). Throughout this book, we will work with the following data types:\nlogical values (aka. Boolean values, of type logical) numbers (of type integer or double) text or string data (of type character) dates and times (with various data types)\nWe already defined objects of type “integer”, “double”, “character” and “logical” above.\nFunctions\nIn general, we need to use parentheses to evaluate a function. If you type ls, the function is not evaluated and instead R shows you the code that defines the function. If you type ls() the function is evaluated and, as seen above, we see objects in the workspace.\nUnlike ls, most functions require one or more arguments. Below is an example of how we assign an object to the argument of the function log. Remember that we earlier defined a to be 1:\nTEST - DID THIS WORK\nHere is the material for this chapter\nR Basics\nFunction help is always organised in the same way. For example, look at the help for `?beepr::beep`. At the top, it tells you the name of the function and its package in curly brackets, then a short description of the function, followed by a longer description. The **Usage** section shows the function with all of its `r glossary(“argument”, “arguments”)`. If any of those arguments have default values, they will be shown like `function(arg = default)`. The **Arguments** section lists each argument with an explanation. There may be a **Details** section after this with even more detail about the functions. The **Examples** section is last, and shows examples that you can run in your console window to see how the function works.\n\n\n\n\n\n\nNote\n\n\n\n## Function Help\n- What is the first argument to the `mean` function? `r mcq(c(“trim”, “na.rm”, “mean”, answer=“x”))`\n- What package is `read_excel` in? `r mcq(c(“readr”, answer=“readxl”, “base”, “stats”))`\n\n\n### Arguments\nYou can look up the arguments/options that a function has by using the help documentation. Some arguments are required, and some are optional. Optional arguments will often use a default (normally specified in the help documentation) if you do not enter any value.\nAs an example, look at the help documentation for the function `sample()` which randomly samples items from a list.\n```{r help-doc, eval=FALSE, filename = “Run in the console”}\n?sample\n```\nThe help documentation for `sample()` should appear in the bottom right help panel. In the usage section, we see that `sample()` takes the following form:\n```{r arguments, eval = FALSE}\nsample(x, size, replace = FALSE, prob = NULL)\n```\nIn the arguments section, there are explanations for each of the arguments. `x` is the list of items we want to choose from, `size` is the number of items we want to choose, `replace` is whether or not each item may be selected more than once, and `prob` gives the probability that each item is chosen. In the details section it notes that if no values are entered for `replace` or `prob` it will use defaults of `FALSE` (each item can only be chosen once) and `NULL` (all items will have equal probability of being chosen). Because there is no default value for `x` or `size`, they must be specified otherwise the code won’t run.\nLet’s try an example and just change the required arguments to `x` and `size` to ask R to choose 5 random letters (`letters` is a built-in `r glossary(“vector”)` of the 26 lower-case Latin letters).\n```{r, echo = FALSE}\n# make sure values are the same\nset.seed(1242016)\n```\n```{r rnorm-n}\nsample(x = letters, size = 5)\n```\n\n\n\n\n\n\nNote\n\n\n\n\n\n## Why are my letters different to your letters?\n`sample()` generates a random sample. Each time you run the code, you’ll generate a different set of random letters (try it). The function `set.seed()` controls the random number generator - if you’re using any functions that use randomness (such as `sample()`), running `set.seed()` will ensure that you get the same result (in many cases this may not be what you want to do). To get the same numbers we do, run `set.seed(1242016)` in the console, and then run `sample(x = letters, size = 5)` again.\n\n\n\nNow we can change the default value for the `replace` argument to produce a set of letters that is allowed to have duplicates.\n```{r}\nset.seed(8675309)\nsample(x = letters, size = 5, replace = TRUE)\n```\nThis time R has still produced 5 random letters, but now this set of letters has two instances of “k”. Always remember to use the help documentation to help you understand what arguments a function requires.\n### Argument names\nIn the above examples, we have written out the argument names in our code (i.e., `x`, `size`, `replace`), however, this is not strictly necessary. The following two lines of code would both produce the same result (although each time you run `sample()` it will produce a slightly different result, because it’s random, but they would still work the same):\n```{r argument-names, eval = FALSE}\nsample(x = letters, size = 5, replace = TRUE)\nsample(letters, 5, TRUE)\n```\nImportantly, if you do not write out the argument names, R will use the default order of arguments. That is, for `sample` it will assume that the first value you enter is `x`, the second value is `size` and the third value is `replace`.\nIf you write out the argument names, then you can write the arguments in whatever order you like:\n```{r argument-order, eval = FALSE}\nsample(size = 5, replace = TRUE, x = letters)\n```\nWhen you are first learning R, you may find it useful to write out the argument names as it can help you remember and understand what each part of the function is doing. However, as your skills progress you may find it quicker to omit the argument names and you will also see code examples online that do not use argument names, so it is important to be able to understand which argument each bit of code is referring to (or look up the help documentation to check).\nIn this course, we will always write out the argument names the first time we use each function. However, in subsequent uses they may be omitted.\n### Tab auto-complete\nOne very useful feature of R Studio is tab auto-complete for functions. If you write the name of the function and then press the tab key, R Studio will show you the arguments that function takes along with a brief description. If you press enter on the argument name it will fill in the name for you, just like auto-complete on your phone. This is incredibly useful when you are first learning R and you should remember to use this feature frequently.\n```{r fig-autocomplete, echo=FALSE, fig.cap=“Tab auto-complete”}\n#knitr::include_graphics(“images/intro/autocomplete.png”)\n```\n## Objects {#sec-objects}\nA large part of your coding will involve creating and manipulating objects. Objects contain stuff. That stuff can be numbers, words, or the result of operations and analyses. You assign content to an object using `&lt;-`.\nRun the following code in the console, but change the values of `name` and `age` to your own details and change `christmas` to a holiday or date you care about.\n```{r objects, filename = “Run in the console”}\nname &lt;- “Emily”\nage &lt;- 36\ntoday &lt;- Sys.Date()\nchristmas &lt;- as.Date(“2023-12-25”)\n```\nYou’ll see that four objects now appear in the environment pane:\n- `name` is `r glossary(“character”)` (text) data. In order for R to recognise it as text, it **must** be enclosed in double quotation marks `” “`.\n- `age` is `r glossary(“numeric”)` data. In order for R to recognise this as a number, it **must not** be enclosed in quotation marks.\n- `today` stores the result of the function `Sys.Date()`. This function returns your computer system’s date. Unlike `name` and `age`, which are hard-coded (i.e., they will always return the values you enter), the contents of the object `today` will change dynamically with the date. That is, if you run that function tomorrow, it will update the date to tomorrow’s date.\n- `christmas` is also a date but it’s hard-coded as a specific date. It’s wrapped within the `as.Date()` function that tells R to interpret the character string you provide as a date rather than text.\n\n\n\n\n\n\nNote\n\n\n\nTo print the contents of an object, type the object’s name in the console and press enter. Try printing all four objects now.\n\n\nFinally, a key concept to understand is that objects can interact and you can save the results of those interactions in new object. Edit and run the following code to create these new objects, and then print the contents of each new object.\n```{r intro-objects, filename = “Run in the console”}\ndecade &lt;- age + 10\nfull_name &lt;- paste(name, “Nordmann”)\nhow_long &lt;- christmas - today\n```\n## Getting help {#sec-help}\nYou will feel like you need a *lot* of help when you’re starting to learn. This won’t really go away; it’s impossible to memorise everything. The goal is to learn enough about the structure of R that you can look things up quickly. This is why we’ll introduce specialised jargon in the glossary for each chapter; it’s easier to google “convert `r glossary(”character”)` to `r glossary(“numeric”)` in R” than “make numbers in quotes be actual numbers not words”. In addition to the function help described above, here’s some additional resources you should use often.\n### Package reference manuals\nStart up help in a browser by entering `help.start()` in the console. Click on &lt;if&gt;Packages&lt;/if&gt; under &lt;if&gt;Reference&lt;/if&gt; to see a list of packages. Scroll down to the &lt;pkg&gt;readxl&lt;/pkg&gt; package and click on it to see a list of the functions that are available in that package.\n### Googling\nIf the function help doesn’t help, or you’re not even sure what function you need, try Googling your question. It will take some practice to be able to use the right jargon in your search terms to get what you want. It helps to put “R” or “tidyverse” in the search text, or the name of the relevant package, like “ggplot2”.\n### Vignettes\nMany packages, especially [tidyverse](https://www.tidyverse.org/packages/){target=“_blank”} ones, have helpful websites with vignettes explaining how to use their functions. Some of the vignettes are also available inside R. You can access them from a package’s help page or with the `vignette()` function.\n```{r, eval = FALSE, filename = “Run in the console”}\n# opens a list of available vignettes\nvignette(package = “ggplot2”)\n# opens a specific vignette in the Help pane\nvignette(“ggplot2-specs”, package = “ggplot2”)\n```\nFROM TUTORIAL #2\nR Basics\nFunction help is always organised in the same way. For example, look at the help for `?beepr::beep`. At the top, it tells you the name of the function and its package in curly brackets, then a short description of the function, followed by a longer description. The **Usage** section shows the function with all of its `r glossary(“argument”, “arguments”)`. If any of those arguments have default values, they will be shown like `function(arg = default)`. The **Arguments** section lists each argument with an explanation. There may be a **Details** section after this with even more detail about the functions. The **Examples** section is last, and shows examples that you can run in your console window to see how the function works.\n\n\n\n\n\n\nNote\n\n\n\n## Function Help\n- What is the first argument to the `mean` function? `r mcq(c(“trim”, “na.rm”, “mean”, answer=“x”))`\n- What package is `read_excel` in? `r mcq(c(“readr”, answer=“readxl”, “base”, “stats”))`\n\n\n### Arguments\nYou can look up the arguments/options that a function has by using the help documentation. Some arguments are required, and some are optional. Optional arguments will often use a default (normally specified in the help documentation) if you do not enter any value.\nAs an example, look at the help documentation for the function `sample()` which randomly samples items from a list.\n```{r help-doc, eval=FALSE, filename = “Run in the console”}\n?sample\n```\nThe help documentation for `sample()` should appear in the bottom right help panel. In the usage section, we see that `sample()` takes the following form:\n```{r arguments, eval = FALSE}\nsample(x, size, replace = FALSE, prob = NULL)\n```\nIn the arguments section, there are explanations for each of the arguments. `x` is the list of items we want to choose from, `size` is the number of items we want to choose, `replace` is whether or not each item may be selected more than once, and `prob` gives the probability that each item is chosen. In the details section it notes that if no values are entered for `replace` or `prob` it will use defaults of `FALSE` (each item can only be chosen once) and `NULL` (all items will have equal probability of being chosen). Because there is no default value for `x` or `size`, they must be specified otherwise the code won’t run.\nLet’s try an example and just change the required arguments to `x` and `size` to ask R to choose 5 random letters (`letters` is a built-in `r glossary(“vector”)` of the 26 lower-case Latin letters).\n```{r, echo = FALSE}\n# make sure values are the same\nset.seed(1242016)\n```\n```{r rnorm-n}\nsample(x = letters, size = 5)\n```\n\n\n\n\n\n\nNote\n\n\n\n\n\n## Why are my letters different to your letters?\n`sample()` generates a random sample. Each time you run the code, you’ll generate a different set of random letters (try it). The function `set.seed()` controls the random number generator - if you’re using any functions that use randomness (such as `sample()`), running `set.seed()` will ensure that you get the same result (in many cases this may not be what you want to do). To get the same numbers we do, run `set.seed(1242016)` in the console, and then run `sample(x = letters, size = 5)` again.\n\n\n\nNow we can change the default value for the `replace` argument to produce a set of letters that is allowed to have duplicates.\n```{r}\nset.seed(8675309)\nsample(x = letters, size = 5, replace = TRUE)\n```\nThis time R has still produced 5 random letters, but now this set of letters has two instances of “k”. Always remember to use the help documentation to help you understand what arguments a function requires.\n### Argument names\nIn the above examples, we have written out the argument names in our code (i.e., `x`, `size`, `replace`), however, this is not strictly necessary. The following two lines of code would both produce the same result (although each time you run `sample()` it will produce a slightly different result, because it’s random, but they would still work the same):\n```{r argument-names, eval = FALSE}\nsample(x = letters, size = 5, replace = TRUE)\nsample(letters, 5, TRUE)\n```\nImportantly, if you do not write out the argument names, R will use the default order of arguments. That is, for `sample` it will assume that the first value you enter is `x`, the second value is `size` and the third value is `replace`.\nIf you write out the argument names, then you can write the arguments in whatever order you like:\n```{r argument-order, eval = FALSE}\nsample(size = 5, replace = TRUE, x = letters)\n```\nWhen you are first learning R, you may find it useful to write out the argument names as it can help you remember and understand what each part of the function is doing. However, as your skills progress you may find it quicker to omit the argument names and you will also see code examples online that do not use argument names, so it is important to be able to understand which argument each bit of code is referring to (or look up the help documentation to check).\nIn this course, we will always write out the argument names the first time we use each function. However, in subsequent uses they may be omitted.\n### Tab auto-complete\nOne very useful feature of R Studio is tab auto-complete for functions. If you write the name of the function and then press the tab key, R Studio will show you the arguments that function takes along with a brief description. If you press enter on the argument name it will fill in the name for you, just like auto-complete on your phone. This is incredibly useful when you are first learning R and you should remember to use this feature frequently.\n```{r fig-autocomplete, echo=FALSE, fig.cap=“Tab auto-complete”}\n#knitr::include_graphics(“images/intro/autocomplete.png”)\n```\n## Objects {#sec-objects}\nA large part of your coding will involve creating and manipulating objects. Objects contain stuff. That stuff can be numbers, words, or the result of operations and analyses. You assign content to an object using `&lt;-`.\nRun the following code in the console, but change the values of `name` and `age` to your own details and change `christmas` to a holiday or date you care about.\n```{r objects, filename = “Run in the console”}\nname &lt;- “Emily”\nage &lt;- 36\ntoday &lt;- Sys.Date()\nchristmas &lt;- as.Date(“2023-12-25”)\n```\nYou’ll see that four objects now appear in the environment pane:\n- `name` is `r glossary(“character”)` (text) data. In order for R to recognise it as text, it **must** be enclosed in double quotation marks `” “`.\n- `age` is `r glossary(“numeric”)` data. In order for R to recognise this as a number, it **must not** be enclosed in quotation marks.\n- `today` stores the result of the function `Sys.Date()`. This function returns your computer system’s date. Unlike `name` and `age`, which are hard-coded (i.e., they will always return the values you enter), the contents of the object `today` will change dynamically with the date. That is, if you run that function tomorrow, it will update the date to tomorrow’s date.\n- `christmas` is also a date but it’s hard-coded as a specific date. It’s wrapped within the `as.Date()` function that tells R to interpret the character string you provide as a date rather than text.\n\n\n\n\n\n\nNote\n\n\n\nTo print the contents of an object, type the object’s name in the console and press enter. Try printing all four objects now.\n\n\nFinally, a key concept to understand is that objects can interact and you can save the results of those interactions in new object. Edit and run the following code to create these new objects, and then print the contents of each new object.\n```{r intro-objects, filename = “Run in the console”}\ndecade &lt;- age + 10\nfull_name &lt;- paste(name, “Nordmann”)\nhow_long &lt;- christmas - today\n```\n## Getting help {#sec-help}\nYou will feel like you need a *lot* of help when you’re starting to learn. This won’t really go away; it’s impossible to memorise everything. The goal is to learn enough about the structure of R that you can look things up quickly. This is why we’ll introduce specialised jargon in the glossary for each chapter; it’s easier to google “convert `r glossary(”character”)` to `r glossary(“numeric”)` in R” than “make numbers in quotes be actual numbers not words”. In addition to the function help described above, here’s some additional resources you should use often.\n### Package reference manuals\nStart up help in a browser by entering `help.start()` in the console. Click on &lt;if&gt;Packages&lt;/if&gt; under &lt;if&gt;Reference&lt;/if&gt; to see a list of packages. Scroll down to the &lt;pkg&gt;readxl&lt;/pkg&gt; package and click on it to see a list of the functions that are available in that package.\n### Googling\nIf the function help doesn’t help, or you’re not even sure what function you need, try Googling your question. It will take some practice to be able to use the right jargon in your search terms to get what you want. It helps to put “R” or “tidyverse” in the search text, or the name of the relevant package, like “ggplot2”.\n### Vignettes\nMany packages, especially [tidyverse](https://www.tidyverse.org/packages/){target=“_blank”} ones, have helpful websites with vignettes explaining how to use their functions. Some of the vignettes are also available inside R. You can access them from a package’s help page or with the `vignette()` function.\n```{r, eval = FALSE, filename = “Run in the console”}\n# opens a list of available vignettes\nvignette(package = “ggplot2”)\n# opens a specific vignette in the Help pane\nvignette(“ggplot2-specs”, package = “ggplot2”)\n```\n## Coding Etiquette\nhttps://bookdown.org/daniel_dauber_io/r4np_book/r-basics-the-very-fundamentals.html\nNow you know everything to get started, but before we jump into our first project, I would like to briefly touch upon coding etiquette. This is not something that improves your analytical or coding skills directly, but is essential in building good habbits and making your life and those of others a little easier. Consider writing code like growing plants in your garden. You want to nurture the good plants, remove the weed and add labels that tell you which plant it is that you are growing. At the end of the day, you want your garden to be well-maintained. Treat you programming code the same way.\nA script (see Chapter 6.3) of programming code should always have at least the following qualities:\nOnly contains code that is necessary,\nIs easy to read and understand,\nIs self-contained.\nWith simple code this is easily achieved. However, what about more complex and longer code representing a whole set of analytical steps?\n```{r}\n# Very messy code\nlibrary(tidyverse)\nlibrary(jtools)\nmodel1 &lt;- lm(covid_cases_per_1m ~ idv, data = df)\nsumm(model1, scale = TRUE, transform.response = TRUE, vifs = TRUE)\ndf %&gt;% ggplot(aes(x = covid_cases_per_1m, y = idv, col = europe, label = country))+\ntheme_minimal()+ geom_label(nudge_y = 2) + geom_point()\nmodel2 &lt;- lm(cases_per_1m ~ idv + uai + idv*europe + uai*europe, data = df)\nsumm(model2, scale = TRUE, transform.response = TRUE, vifs = TRUE)\nanova(model1, model2)\n```\nHow about the following in comparison?\n```{r}\n# Nicely structured code\n# Load required R packages\nlibrary(tidyverse)\nlibrary(jtools)\n# ---- Modelling COVID-19 cases ----\n## Specify and run a regression\nmodel1 &lt;- lm(covid_cases_per_1m ~ idv, data = df)\n## Retrieve the summary statistics of model1\nsumm(model1,\nscale = TRUE,\ntransform.response = TRUE,\nvifs = TRUE)\n# Does is matter whether a country lies in Europe?\n## Visualise rel. of covid cases, idv and being a European country\ndf %&gt;%\nggplot(aes(x = covid_cases_per_1m,\ny = idv,\ncol = europe,\nlabel = country)) +\ntheme_minimal() +\ngeom_label(nudge_y = 2) +\ngeom_point()\n## Specify and run a revised regression\nmodel2 &lt;- lm(cases_per_1m ~ idv + uai + idv*europe + uai*europe,\ndata = df)\n## Retrieve the summary statistics of model2\nsumm(model2,\nscale = TRUE,\ntransform.response = TRUE,\nvifs = TRUE)\n## Test whether model2 is an improvement over model1\nanova(model1, model2)\n```\nI hope we can agree that the second example is much easier to read and understand even though you probably do not understand most of it yet. For once, I separated the different analytical steps from each other like paragraphs in a report. Apart from that, I added comments with # to provide more context to my code for someone else who wants to understand my analysis. Admittedly, this example is a little excessive. Usually, you might have fewer comments. Commenting is an integral part of programming because it allows you to remember what you did. Ideally, you want to strike a good balance between commenting on and writing your code. How many comments you need will likely change throughout your R programming journey. Think of comments as headers for your programming script that give it structure.\nWe can use # not only to write comments but also to tell R not to run particular code. This is very helpful if you want to keep some code but do not want to use it yet. There is also a handy keyboard shortcut you can use to ‘deactivate’ multiple lines of code at once. Select whatever you want to ‘comment out’ in your script and press Ctrl+Shift+C (PC) or Cmd+Shift+C (Mac).\n```{r}\n# mean(pocket_money) # R will NOT run this code\nmean(pocket_money) # R will run this code\n```\nRStudio helps a lot with keeping your coding tidy and properly formatted. However, there are some additional aspects worth considering. If you want to find out more about coding style, I highly recommend to read through ‘The tidyverse style guide’ (Wickham, 2021)."
  },
  {
    "objectID": "tutorial4.html#sec-intro-errors",
    "href": "tutorial4.html#sec-intro-errors",
    "title": "tutorial4.qmd",
    "section": "",
    "text": "One thing that intimidates new R and RStudio users is how it reports errors, warnings, and messages. R reports errors, warnings, and messages in a glaring red font, which makes it seem like it is scolding you. However, seeing red text in the console is not always bad.\nR will show red text in the console pane in three different situations:\nErrors: When the red text is a legitimate error, it will be prefaced with “Error in…” and will try to explain what went wrong. Generally when there’s an error, the code will not run. For example, we’ll see in Subsection 1.3.3 if you see Error in ggplot(…) : could not find function “ggplot”, it means that the ggplot() function is not accessible because the package that contains the function (ggplot2) was not loaded with library(ggplot2). Thus you cannot use the ggplot() function without the ggplot2 package being loaded first. Warnings: When the red text is a warning, it will be prefaced with “Warning:” and R will try to explain why there’s a warning. Generally your code will still work, but with some caveats. For example, you will see in Chapter 2 if you create a scatterplot based on a dataset where two of the rows of data have missing entries that would be needed to create points in the scatterplot, you will see this warning: Warning: Removed 2 rows containing missing values (geom_point). R will still produce the scatterplot with all the remaining non-missing values, but it is warning you that two of the points aren’t there. Messages: When the red text doesn’t start with either “Error” or “Warning”, it’s just a friendly message. You’ll see these messages when you load R packages in the upcoming Subsection 1.3.2 or when you read data saved in spreadsheet files with the read_csv() function as you’ll see in Chapter 4. These are helpful diagnostic messages and they don’t stop your code from working. Additionally, you’ll see these messages when you install packages too using install.packages() as discussed in Subsection 1.3.1. Remember, when you see red text in the console, don’t panic. It doesn’t necessarily mean anything is wrong. Rather:\nIf the text starts with “Error”, figure out what’s causing it. Think of errors as a red traffic light: something is wrong! If the text starts with “Warning”, figure out if it’s something to worry about. For instance, if you get a warning about missing values in a scatterplot and you know there are missing values, you’re fine. If that’s surprising, look at your data and see what’s missing. Think of warnings as a yellow traffic light: everything is working fine, but watch out/pay attention. Otherwise, the text is just a message. Read it, wave back at R, and thank it for talking to you. Think of messages as a green traffic light: everything is working fine and keep on going!"
  },
  {
    "objectID": "tutorial4.html#sec-intro-tips_coding",
    "href": "tutorial4.html#sec-intro-tips_coding",
    "title": "tutorial4.qmd",
    "section": "",
    "text": "Learning to code/program is quite similar to learning a foreign language. It can be daunting and frustrating at first. Such frustrations are common and it is normal to feel discouraged as you learn. However, just as with learning a foreign language, if you put in the effort and are not afraid to make mistakes, anybody can learn and improve.\nHere are a few useful tips to keep in mind as you learn to program:\nRemember that computers are not actually that smart: You may think your computer or smartphone is “smart,” but really people spent a lot of time and energy designing them to appear “smart.” In reality, you have to tell a computer everything it needs to do. Furthermore, the instructions you give your computer can’t have any mistakes in them, nor can they be ambiguous in any way. Take the “copy, paste, and tweak” approach: Especially when you learn your first programming language or you need to understand particularly complicated code, it is often much easier to take existing code that you know works and modify it to suit your ends. This is as opposed to trying to type out the code from scratch. We call this the “copy, paste, and tweak” approach. So early on, we suggest not trying to write code from memory, but rather take existing examples we have provided you, then copy, paste, and tweak them to suit your goals. After you start feeling more confident, you can slowly move away from this approach and write code from scratch. Think of the “copy, paste, and tweak” approach as training wheels for a child learning to ride a bike. After getting comfortable, they won’t need them anymore. The best way to learn to code is by doing: Rather than learning to code for its own sake, we find that learning to code goes much smoother when you have a goal in mind or when you are working on a particular project, like analyzing data that you are interested in and that is important to you. Practice is key: Just as the only method to improve your foreign language skills is through lots of practice and speaking, the only method to improving your coding skills is through lots of practice. Don’t worry, however, we’ll give you plenty of opportunities to do so!"
  },
  {
    "objectID": "tutorial4.html#unused-text",
    "href": "tutorial4.html#unused-text",
    "title": "tutorial4.qmd",
    "section": "",
    "text": "Everything that exists in R must be represented somehow. A generic term for something that we know not much about is an object. In R, we can distinguish between two main types of objects:\n\ndata objects are typically passive containers for values (e.g., numbers, truth values, or strings of text), whereas\nfunction objects are active elements or tools: They do things with data.\n\nMastering R (or any other programming language) essentially consists of solving two inter-related tasks:\n\nRepresenting various types of data as objects.\nManipulating those objects by using functions.\n\nFor any data object, we distinguish between its type and its shape. The shape of an object mostly depends on its structure. As this chapter uses only a single data structure (i.e., vectors), we will address issues of data shape later (in Chapter 3 on Data structures).\nHere, we focus on data types (which are also described as data modes in R). Throughout this book, we will work with the following data types:\nlogical values (aka. Boolean values, of type logical) numbers (of type integer or double) text or string data (of type character) dates and times (with various data types)\nWe already defined objects of type “integer”, “double”, “character” and “logical” above.\nFunctions\nIn general, we need to use parentheses to evaluate a function. If you type ls, the function is not evaluated and instead R shows you the code that defines the function. If you type ls() the function is evaluated and, as seen above, we see objects in the workspace.\nUnlike ls, most functions require one or more arguments. Below is an example of how we assign an object to the argument of the function log. Remember that we earlier defined a to be 1:\nTEST - DID THIS WORK\nHere is the material for this chapter\nR Basics\nFunction help is always organised in the same way. For example, look at the help for `?beepr::beep`. At the top, it tells you the name of the function and its package in curly brackets, then a short description of the function, followed by a longer description. The **Usage** section shows the function with all of its `r glossary(“argument”, “arguments”)`. If any of those arguments have default values, they will be shown like `function(arg = default)`. The **Arguments** section lists each argument with an explanation. There may be a **Details** section after this with even more detail about the functions. The **Examples** section is last, and shows examples that you can run in your console window to see how the function works.\n\n\n\n\n\n\nNote\n\n\n\n## Function Help\n- What is the first argument to the `mean` function? `r mcq(c(“trim”, “na.rm”, “mean”, answer=“x”))`\n- What package is `read_excel` in? `r mcq(c(“readr”, answer=“readxl”, “base”, “stats”))`\n\n\n### Arguments\nYou can look up the arguments/options that a function has by using the help documentation. Some arguments are required, and some are optional. Optional arguments will often use a default (normally specified in the help documentation) if you do not enter any value.\nAs an example, look at the help documentation for the function `sample()` which randomly samples items from a list.\n```{r help-doc, eval=FALSE, filename = “Run in the console”}\n?sample\n```\nThe help documentation for `sample()` should appear in the bottom right help panel. In the usage section, we see that `sample()` takes the following form:\n```{r arguments, eval = FALSE}\nsample(x, size, replace = FALSE, prob = NULL)\n```\nIn the arguments section, there are explanations for each of the arguments. `x` is the list of items we want to choose from, `size` is the number of items we want to choose, `replace` is whether or not each item may be selected more than once, and `prob` gives the probability that each item is chosen. In the details section it notes that if no values are entered for `replace` or `prob` it will use defaults of `FALSE` (each item can only be chosen once) and `NULL` (all items will have equal probability of being chosen). Because there is no default value for `x` or `size`, they must be specified otherwise the code won’t run.\nLet’s try an example and just change the required arguments to `x` and `size` to ask R to choose 5 random letters (`letters` is a built-in `r glossary(“vector”)` of the 26 lower-case Latin letters).\n```{r, echo = FALSE}\n# make sure values are the same\nset.seed(1242016)\n```\n```{r rnorm-n}\nsample(x = letters, size = 5)\n```\n\n\n\n\n\n\nNote\n\n\n\n\n\n## Why are my letters different to your letters?\n`sample()` generates a random sample. Each time you run the code, you’ll generate a different set of random letters (try it). The function `set.seed()` controls the random number generator - if you’re using any functions that use randomness (such as `sample()`), running `set.seed()` will ensure that you get the same result (in many cases this may not be what you want to do). To get the same numbers we do, run `set.seed(1242016)` in the console, and then run `sample(x = letters, size = 5)` again.\n\n\n\nNow we can change the default value for the `replace` argument to produce a set of letters that is allowed to have duplicates.\n```{r}\nset.seed(8675309)\nsample(x = letters, size = 5, replace = TRUE)\n```\nThis time R has still produced 5 random letters, but now this set of letters has two instances of “k”. Always remember to use the help documentation to help you understand what arguments a function requires.\n### Argument names\nIn the above examples, we have written out the argument names in our code (i.e., `x`, `size`, `replace`), however, this is not strictly necessary. The following two lines of code would both produce the same result (although each time you run `sample()` it will produce a slightly different result, because it’s random, but they would still work the same):\n```{r argument-names, eval = FALSE}\nsample(x = letters, size = 5, replace = TRUE)\nsample(letters, 5, TRUE)\n```\nImportantly, if you do not write out the argument names, R will use the default order of arguments. That is, for `sample` it will assume that the first value you enter is `x`, the second value is `size` and the third value is `replace`.\nIf you write out the argument names, then you can write the arguments in whatever order you like:\n```{r argument-order, eval = FALSE}\nsample(size = 5, replace = TRUE, x = letters)\n```\nWhen you are first learning R, you may find it useful to write out the argument names as it can help you remember and understand what each part of the function is doing. However, as your skills progress you may find it quicker to omit the argument names and you will also see code examples online that do not use argument names, so it is important to be able to understand which argument each bit of code is referring to (or look up the help documentation to check).\nIn this course, we will always write out the argument names the first time we use each function. However, in subsequent uses they may be omitted.\n### Tab auto-complete\nOne very useful feature of R Studio is tab auto-complete for functions. If you write the name of the function and then press the tab key, R Studio will show you the arguments that function takes along with a brief description. If you press enter on the argument name it will fill in the name for you, just like auto-complete on your phone. This is incredibly useful when you are first learning R and you should remember to use this feature frequently.\n```{r fig-autocomplete, echo=FALSE, fig.cap=“Tab auto-complete”}\n#knitr::include_graphics(“images/intro/autocomplete.png”)\n```\n## Objects {#sec-objects}\nA large part of your coding will involve creating and manipulating objects. Objects contain stuff. That stuff can be numbers, words, or the result of operations and analyses. You assign content to an object using `&lt;-`.\nRun the following code in the console, but change the values of `name` and `age` to your own details and change `christmas` to a holiday or date you care about.\n```{r objects, filename = “Run in the console”}\nname &lt;- “Emily”\nage &lt;- 36\ntoday &lt;- Sys.Date()\nchristmas &lt;- as.Date(“2023-12-25”)\n```\nYou’ll see that four objects now appear in the environment pane:\n- `name` is `r glossary(“character”)` (text) data. In order for R to recognise it as text, it **must** be enclosed in double quotation marks `” “`.\n- `age` is `r glossary(“numeric”)` data. In order for R to recognise this as a number, it **must not** be enclosed in quotation marks.\n- `today` stores the result of the function `Sys.Date()`. This function returns your computer system’s date. Unlike `name` and `age`, which are hard-coded (i.e., they will always return the values you enter), the contents of the object `today` will change dynamically with the date. That is, if you run that function tomorrow, it will update the date to tomorrow’s date.\n- `christmas` is also a date but it’s hard-coded as a specific date. It’s wrapped within the `as.Date()` function that tells R to interpret the character string you provide as a date rather than text.\n\n\n\n\n\n\nNote\n\n\n\nTo print the contents of an object, type the object’s name in the console and press enter. Try printing all four objects now.\n\n\nFinally, a key concept to understand is that objects can interact and you can save the results of those interactions in new object. Edit and run the following code to create these new objects, and then print the contents of each new object.\n```{r intro-objects, filename = “Run in the console”}\ndecade &lt;- age + 10\nfull_name &lt;- paste(name, “Nordmann”)\nhow_long &lt;- christmas - today\n```\n## Getting help {#sec-help}\nYou will feel like you need a *lot* of help when you’re starting to learn. This won’t really go away; it’s impossible to memorise everything. The goal is to learn enough about the structure of R that you can look things up quickly. This is why we’ll introduce specialised jargon in the glossary for each chapter; it’s easier to google “convert `r glossary(”character”)` to `r glossary(“numeric”)` in R” than “make numbers in quotes be actual numbers not words”. In addition to the function help described above, here’s some additional resources you should use often.\n### Package reference manuals\nStart up help in a browser by entering `help.start()` in the console. Click on &lt;if&gt;Packages&lt;/if&gt; under &lt;if&gt;Reference&lt;/if&gt; to see a list of packages. Scroll down to the &lt;pkg&gt;readxl&lt;/pkg&gt; package and click on it to see a list of the functions that are available in that package.\n### Googling\nIf the function help doesn’t help, or you’re not even sure what function you need, try Googling your question. It will take some practice to be able to use the right jargon in your search terms to get what you want. It helps to put “R” or “tidyverse” in the search text, or the name of the relevant package, like “ggplot2”.\n### Vignettes\nMany packages, especially [tidyverse](https://www.tidyverse.org/packages/){target=“_blank”} ones, have helpful websites with vignettes explaining how to use their functions. Some of the vignettes are also available inside R. You can access them from a package’s help page or with the `vignette()` function.\n```{r, eval = FALSE, filename = “Run in the console”}\n# opens a list of available vignettes\nvignette(package = “ggplot2”)\n# opens a specific vignette in the Help pane\nvignette(“ggplot2-specs”, package = “ggplot2”)\n```\nFROM TUTORIAL #2\nR Basics\nFunction help is always organised in the same way. For example, look at the help for `?beepr::beep`. At the top, it tells you the name of the function and its package in curly brackets, then a short description of the function, followed by a longer description. The **Usage** section shows the function with all of its `r glossary(“argument”, “arguments”)`. If any of those arguments have default values, they will be shown like `function(arg = default)`. The **Arguments** section lists each argument with an explanation. There may be a **Details** section after this with even more detail about the functions. The **Examples** section is last, and shows examples that you can run in your console window to see how the function works.\n\n\n\n\n\n\nNote\n\n\n\n## Function Help\n- What is the first argument to the `mean` function? `r mcq(c(“trim”, “na.rm”, “mean”, answer=“x”))`\n- What package is `read_excel` in? `r mcq(c(“readr”, answer=“readxl”, “base”, “stats”))`\n\n\n### Arguments\nYou can look up the arguments/options that a function has by using the help documentation. Some arguments are required, and some are optional. Optional arguments will often use a default (normally specified in the help documentation) if you do not enter any value.\nAs an example, look at the help documentation for the function `sample()` which randomly samples items from a list.\n```{r help-doc, eval=FALSE, filename = “Run in the console”}\n?sample\n```\nThe help documentation for `sample()` should appear in the bottom right help panel. In the usage section, we see that `sample()` takes the following form:\n```{r arguments, eval = FALSE}\nsample(x, size, replace = FALSE, prob = NULL)\n```\nIn the arguments section, there are explanations for each of the arguments. `x` is the list of items we want to choose from, `size` is the number of items we want to choose, `replace` is whether or not each item may be selected more than once, and `prob` gives the probability that each item is chosen. In the details section it notes that if no values are entered for `replace` or `prob` it will use defaults of `FALSE` (each item can only be chosen once) and `NULL` (all items will have equal probability of being chosen). Because there is no default value for `x` or `size`, they must be specified otherwise the code won’t run.\nLet’s try an example and just change the required arguments to `x` and `size` to ask R to choose 5 random letters (`letters` is a built-in `r glossary(“vector”)` of the 26 lower-case Latin letters).\n```{r, echo = FALSE}\n# make sure values are the same\nset.seed(1242016)\n```\n```{r rnorm-n}\nsample(x = letters, size = 5)\n```\n\n\n\n\n\n\nNote\n\n\n\n\n\n## Why are my letters different to your letters?\n`sample()` generates a random sample. Each time you run the code, you’ll generate a different set of random letters (try it). The function `set.seed()` controls the random number generator - if you’re using any functions that use randomness (such as `sample()`), running `set.seed()` will ensure that you get the same result (in many cases this may not be what you want to do). To get the same numbers we do, run `set.seed(1242016)` in the console, and then run `sample(x = letters, size = 5)` again.\n\n\n\nNow we can change the default value for the `replace` argument to produce a set of letters that is allowed to have duplicates.\n```{r}\nset.seed(8675309)\nsample(x = letters, size = 5, replace = TRUE)\n```\nThis time R has still produced 5 random letters, but now this set of letters has two instances of “k”. Always remember to use the help documentation to help you understand what arguments a function requires.\n### Argument names\nIn the above examples, we have written out the argument names in our code (i.e., `x`, `size`, `replace`), however, this is not strictly necessary. The following two lines of code would both produce the same result (although each time you run `sample()` it will produce a slightly different result, because it’s random, but they would still work the same):\n```{r argument-names, eval = FALSE}\nsample(x = letters, size = 5, replace = TRUE)\nsample(letters, 5, TRUE)\n```\nImportantly, if you do not write out the argument names, R will use the default order of arguments. That is, for `sample` it will assume that the first value you enter is `x`, the second value is `size` and the third value is `replace`.\nIf you write out the argument names, then you can write the arguments in whatever order you like:\n```{r argument-order, eval = FALSE}\nsample(size = 5, replace = TRUE, x = letters)\n```\nWhen you are first learning R, you may find it useful to write out the argument names as it can help you remember and understand what each part of the function is doing. However, as your skills progress you may find it quicker to omit the argument names and you will also see code examples online that do not use argument names, so it is important to be able to understand which argument each bit of code is referring to (or look up the help documentation to check).\nIn this course, we will always write out the argument names the first time we use each function. However, in subsequent uses they may be omitted.\n### Tab auto-complete\nOne very useful feature of R Studio is tab auto-complete for functions. If you write the name of the function and then press the tab key, R Studio will show you the arguments that function takes along with a brief description. If you press enter on the argument name it will fill in the name for you, just like auto-complete on your phone. This is incredibly useful when you are first learning R and you should remember to use this feature frequently.\n```{r fig-autocomplete, echo=FALSE, fig.cap=“Tab auto-complete”}\n#knitr::include_graphics(“images/intro/autocomplete.png”)\n```\n## Objects {#sec-objects}\nA large part of your coding will involve creating and manipulating objects. Objects contain stuff. That stuff can be numbers, words, or the result of operations and analyses. You assign content to an object using `&lt;-`.\nRun the following code in the console, but change the values of `name` and `age` to your own details and change `christmas` to a holiday or date you care about.\n```{r objects, filename = “Run in the console”}\nname &lt;- “Emily”\nage &lt;- 36\ntoday &lt;- Sys.Date()\nchristmas &lt;- as.Date(“2023-12-25”)\n```\nYou’ll see that four objects now appear in the environment pane:\n- `name` is `r glossary(“character”)` (text) data. In order for R to recognise it as text, it **must** be enclosed in double quotation marks `” “`.\n- `age` is `r glossary(“numeric”)` data. In order for R to recognise this as a number, it **must not** be enclosed in quotation marks.\n- `today` stores the result of the function `Sys.Date()`. This function returns your computer system’s date. Unlike `name` and `age`, which are hard-coded (i.e., they will always return the values you enter), the contents of the object `today` will change dynamically with the date. That is, if you run that function tomorrow, it will update the date to tomorrow’s date.\n- `christmas` is also a date but it’s hard-coded as a specific date. It’s wrapped within the `as.Date()` function that tells R to interpret the character string you provide as a date rather than text.\n\n\n\n\n\n\nNote\n\n\n\nTo print the contents of an object, type the object’s name in the console and press enter. Try printing all four objects now.\n\n\nFinally, a key concept to understand is that objects can interact and you can save the results of those interactions in new object. Edit and run the following code to create these new objects, and then print the contents of each new object.\n```{r intro-objects, filename = “Run in the console”}\ndecade &lt;- age + 10\nfull_name &lt;- paste(name, “Nordmann”)\nhow_long &lt;- christmas - today\n```\n## Getting help {#sec-help}\nYou will feel like you need a *lot* of help when you’re starting to learn. This won’t really go away; it’s impossible to memorise everything. The goal is to learn enough about the structure of R that you can look things up quickly. This is why we’ll introduce specialised jargon in the glossary for each chapter; it’s easier to google “convert `r glossary(”character”)` to `r glossary(“numeric”)` in R” than “make numbers in quotes be actual numbers not words”. In addition to the function help described above, here’s some additional resources you should use often.\n### Package reference manuals\nStart up help in a browser by entering `help.start()` in the console. Click on &lt;if&gt;Packages&lt;/if&gt; under &lt;if&gt;Reference&lt;/if&gt; to see a list of packages. Scroll down to the &lt;pkg&gt;readxl&lt;/pkg&gt; package and click on it to see a list of the functions that are available in that package.\n### Googling\nIf the function help doesn’t help, or you’re not even sure what function you need, try Googling your question. It will take some practice to be able to use the right jargon in your search terms to get what you want. It helps to put “R” or “tidyverse” in the search text, or the name of the relevant package, like “ggplot2”.\n### Vignettes\nMany packages, especially [tidyverse](https://www.tidyverse.org/packages/){target=“_blank”} ones, have helpful websites with vignettes explaining how to use their functions. Some of the vignettes are also available inside R. You can access them from a package’s help page or with the `vignette()` function.\n```{r, eval = FALSE, filename = “Run in the console”}\n# opens a list of available vignettes\nvignette(package = “ggplot2”)\n# opens a specific vignette in the Help pane\nvignette(“ggplot2-specs”, package = “ggplot2”)\n```\n## Coding Etiquette\nhttps://bookdown.org/daniel_dauber_io/r4np_book/r-basics-the-very-fundamentals.html\nNow you know everything to get started, but before we jump into our first project, I would like to briefly touch upon coding etiquette. This is not something that improves your analytical or coding skills directly, but is essential in building good habbits and making your life and those of others a little easier. Consider writing code like growing plants in your garden. You want to nurture the good plants, remove the weed and add labels that tell you which plant it is that you are growing. At the end of the day, you want your garden to be well-maintained. Treat you programming code the same way.\nA script (see Chapter 6.3) of programming code should always have at least the following qualities:\nOnly contains code that is necessary,\nIs easy to read and understand,\nIs self-contained.\nWith simple code this is easily achieved. However, what about more complex and longer code representing a whole set of analytical steps?\n```{r}\n# Very messy code\nlibrary(tidyverse)\nlibrary(jtools)\nmodel1 &lt;- lm(covid_cases_per_1m ~ idv, data = df)\nsumm(model1, scale = TRUE, transform.response = TRUE, vifs = TRUE)\ndf %&gt;% ggplot(aes(x = covid_cases_per_1m, y = idv, col = europe, label = country))+\ntheme_minimal()+ geom_label(nudge_y = 2) + geom_point()\nmodel2 &lt;- lm(cases_per_1m ~ idv + uai + idv*europe + uai*europe, data = df)\nsumm(model2, scale = TRUE, transform.response = TRUE, vifs = TRUE)\nanova(model1, model2)\n```\nHow about the following in comparison?\n```{r}\n# Nicely structured code\n# Load required R packages\nlibrary(tidyverse)\nlibrary(jtools)\n# ---- Modelling COVID-19 cases ----\n## Specify and run a regression\nmodel1 &lt;- lm(covid_cases_per_1m ~ idv, data = df)\n## Retrieve the summary statistics of model1\nsumm(model1,\nscale = TRUE,\ntransform.response = TRUE,\nvifs = TRUE)\n# Does is matter whether a country lies in Europe?\n## Visualise rel. of covid cases, idv and being a European country\ndf %&gt;%\nggplot(aes(x = covid_cases_per_1m,\ny = idv,\ncol = europe,\nlabel = country)) +\ntheme_minimal() +\ngeom_label(nudge_y = 2) +\ngeom_point()\n## Specify and run a revised regression\nmodel2 &lt;- lm(cases_per_1m ~ idv + uai + idv*europe + uai*europe,\ndata = df)\n## Retrieve the summary statistics of model2\nsumm(model2,\nscale = TRUE,\ntransform.response = TRUE,\nvifs = TRUE)\n## Test whether model2 is an improvement over model1\nanova(model1, model2)\n```\nI hope we can agree that the second example is much easier to read and understand even though you probably do not understand most of it yet. For once, I separated the different analytical steps from each other like paragraphs in a report. Apart from that, I added comments with # to provide more context to my code for someone else who wants to understand my analysis. Admittedly, this example is a little excessive. Usually, you might have fewer comments. Commenting is an integral part of programming because it allows you to remember what you did. Ideally, you want to strike a good balance between commenting on and writing your code. How many comments you need will likely change throughout your R programming journey. Think of comments as headers for your programming script that give it structure.\nWe can use # not only to write comments but also to tell R not to run particular code. This is very helpful if you want to keep some code but do not want to use it yet. There is also a handy keyboard shortcut you can use to ‘deactivate’ multiple lines of code at once. Select whatever you want to ‘comment out’ in your script and press Ctrl+Shift+C (PC) or Cmd+Shift+C (Mac).\n```{r}\n# mean(pocket_money) # R will NOT run this code\nmean(pocket_money) # R will run this code\n```\nRStudio helps a lot with keeping your coding tidy and properly formatted. However, there are some additional aspects worth considering. If you want to find out more about coding style, I highly recommend to read through ‘The tidyverse style guide’ (Wickham, 2021)."
  }
]